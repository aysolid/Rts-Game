<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Realm of Conquest - RTS Game</title>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700;900&family=Almendra:wght@400;700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --gold: #d4a84b;
            --gold-dark: #8b6914;
            --wood-brown: #8b4513;
            --stone-gray: #708090;
            --food-green: #228b22;
            --gem-purple: #9932cc;
            --parchment: #f4e4bc;
            --parchment-dark: #d4c4a0;
            --ink: #2c1810;
            --blood-red: #8b0000;
        }

        body {
            font-family: 'Almendra', serif;
            background: #1a1a2e;
            overflow: hidden;
            user-select: none;
        }

        #game-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
        }

        #game-container.hidden {
            display: none;
        }

        /* Top Resource Bar */
        #resource-bar {
            display: flex;
            justify-content: center;
            gap: 30px;
            padding: 12px 20px;
            background: linear-gradient(180deg, rgba(44, 24, 16, 0.95) 0%, rgba(20, 10, 5, 0.98) 100%);
            border-bottom: 3px solid var(--gold-dark);
            box-shadow: 0 4px 20px rgba(0,0,0,0.5), inset 0 -1px 0 rgba(212, 168, 75, 0.3);
        }

        .resource {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 16px;
            background: linear-gradient(180deg, rgba(244, 228, 188, 0.1) 0%, rgba(244, 228, 188, 0.05) 100%);
            border: 1px solid rgba(212, 168, 75, 0.4);
            border-radius: 4px;
            position: relative;
        }

        .resource-icon {
            width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.5));
        }

        .resource-amount {
            font-family: 'Cinzel', serif;
            font-size: 18px;
            font-weight: 700;
            color: var(--parchment);
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
            min-width: 50px;
        }

        .resource-rate {
            font-size: 12px;
            color: #90EE90;
            position: absolute;
            bottom: 2px;
            right: 8px;
        }

        /* Main Game Area */
        #main-area {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        /* Game Canvas */
        #game-canvas {
            flex: 1;
            cursor: crosshair;
        }

        /* Right Panel - Build Menu */
        #build-panel {
            width: 280px;
            background: linear-gradient(180deg, rgba(44, 24, 16, 0.95) 0%, rgba(30, 15, 8, 0.98) 100%);
            border-left: 3px solid var(--gold-dark);
            padding: 15px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            overflow-y: auto;
        }

        .panel-header {
            font-family: 'Cinzel', serif;
            font-size: 20px;
            font-weight: 900;
            color: var(--gold);
            text-align: center;
            padding-bottom: 10px;
            border-bottom: 2px solid var(--gold-dark);
            text-shadow: 0 2px 8px rgba(212, 168, 75, 0.5);
            letter-spacing: 2px;
        }

        .build-category {
            margin-bottom: 10px;
        }

        .category-title {
            font-family: 'Cinzel', serif;
            font-size: 14px;
            color: var(--parchment-dark);
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .build-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
        }

        .build-btn {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 12px 8px;
            background: linear-gradient(180deg, rgba(139, 69, 19, 0.6) 0%, rgba(70, 35, 10, 0.8) 100%);
            border: 2px solid var(--gold-dark);
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
        }

        .build-btn:hover:not(.disabled) {
            background: linear-gradient(180deg, rgba(212, 168, 75, 0.4) 0%, rgba(139, 69, 19, 0.8) 100%);
            border-color: var(--gold);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(212, 168, 75, 0.3);
        }

        .build-btn.selected {
            background: linear-gradient(180deg, rgba(212, 168, 75, 0.6) 0%, rgba(139, 105, 25, 0.8) 100%);
            border-color: var(--gold);
            box-shadow: 0 0 15px rgba(212, 168, 75, 0.5), inset 0 0 10px rgba(212, 168, 75, 0.2);
        }

        .build-btn.disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .build-icon {
            font-size: 28px;
            margin-bottom: 4px;
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.5));
        }

        .build-name {
            font-family: 'Almendra', serif;
            font-size: 11px;
            color: var(--parchment);
            text-align: center;
            line-height: 1.2;
        }

        .build-cost {
            font-size: 9px;
            color: var(--parchment-dark);
            margin-top: 4px;
        }

        /* Bottom Info Bar */
        #info-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 20px;
            background: linear-gradient(0deg, rgba(44, 24, 16, 0.98) 0%, rgba(30, 15, 8, 0.95) 100%);
            border-top: 3px solid var(--gold-dark);
            min-height: 80px;
        }

        #selection-info {
            flex: 1;
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .selection-portrait {
            width: 60px;
            height: 60px;
            background: rgba(0,0,0,0.4);
            border: 2px solid var(--gold-dark);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 32px;
        }

        .selection-details {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .selection-name {
            font-family: 'Cinzel', serif;
            font-size: 16px;
            font-weight: 700;
            color: var(--gold);
        }

        .selection-stats {
            font-size: 12px;
            color: var(--parchment-dark);
        }

        #unit-actions {
            display: flex;
            gap: 8px;
        }

        .action-btn {
            width: 50px;
            height: 50px;
            background: linear-gradient(180deg, rgba(139, 69, 19, 0.6) 0%, rgba(70, 35, 10, 0.8) 100%);
            border: 2px solid var(--gold-dark);
            border-radius: 6px;
            cursor: pointer;
            font-size: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }

        .action-btn:hover:not(.disabled) {
            background: linear-gradient(180deg, rgba(212, 168, 75, 0.4) 0%, rgba(139, 69, 19, 0.8) 100%);
            border-color: var(--gold);
        }

        .action-btn.disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .action-btn.active {
            background: linear-gradient(180deg, rgba(34, 139, 34, 0.7) 0%, rgba(0, 100, 0, 0.9) 100%);
            border-color: #90EE90;
            box-shadow: 0 0 8px rgba(144, 238, 144, 0.5);
        }

        #minimap-container {
            width: 180px;
            height: 60px;
            background: rgba(0,0,0,0.5);
            border: 2px solid var(--gold-dark);
            border-radius: 4px;
            overflow: hidden;
        }

        #minimap {
            width: 100%;
            height: 100%;
        }

        /* Game Messages */
        #messages {
            position: absolute;
            top: 80px;
            left: 20px;
            display: flex;
            flex-direction: column;
            gap: 5px;
            pointer-events: none;
        }

        .message {
            padding: 8px 16px;
            background: rgba(0, 0, 0, 0.8);
            border-left: 3px solid var(--gold);
            color: var(--parchment);
            font-size: 14px;
            animation: fadeIn 0.3s ease, fadeOut 0.5s ease 2.5s forwards;
            border-radius: 0 4px 4px 0;
        }

        .message.error {
            border-left-color: var(--blood-red);
            color: #ff6b6b;
        }

        .message.success {
            border-left-color: var(--food-green);
            color: #90EE90;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateX(-20px); }
            to { opacity: 1; transform: translateX(0); }
        }

        @keyframes fadeOut {
            from { opacity: 1; }
            to { opacity: 0; }
        }

        /* Tooltips */
        .tooltip {
            position: absolute;
            background: rgba(20, 10, 5, 0.95);
            border: 2px solid var(--gold-dark);
            border-radius: 6px;
            padding: 10px 14px;
            color: var(--parchment);
            font-size: 12px;
            max-width: 220px;
            z-index: 1000;
            pointer-events: none;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
        }

        .tooltip-title {
            font-family: 'Cinzel', serif;
            font-weight: 700;
            color: var(--gold);
            margin-bottom: 6px;
        }

        .tooltip-desc {
            line-height: 1.4;
            margin-bottom: 8px;
        }

        .tooltip-cost {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            padding-top: 6px;
            border-top: 1px solid var(--gold-dark);
        }

        .tooltip-cost span {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        /* Selection box */
        #selection-box {
            position: absolute;
            border: 1px solid rgba(144, 238, 144, 0.8);
            background: rgba(144, 238, 144, 0.1);
            pointer-events: none;
            display: none;
        }

        /* Game Over / Victory overlay */
        #game-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }

        .overlay-content {
            text-align: center;
            padding: 40px 60px;
            background: linear-gradient(180deg, rgba(44, 24, 16, 0.98) 0%, rgba(20, 10, 5, 0.98) 100%);
            border: 3px solid var(--gold);
            border-radius: 12px;
            box-shadow: 0 0 60px rgba(212, 168, 75, 0.3);
        }

        .overlay-title {
            font-family: 'Cinzel', serif;
            font-size: 48px;
            font-weight: 900;
            color: var(--gold);
            text-shadow: 0 4px 20px rgba(212, 168, 75, 0.5);
            margin-bottom: 20px;
        }

        .overlay-btn {
            padding: 12px 40px;
            font-family: 'Cinzel', serif;
            font-size: 18px;
            background: linear-gradient(180deg, var(--gold) 0%, var(--gold-dark) 100%);
            border: none;
            border-radius: 6px;
            color: var(--ink);
            cursor: pointer;
            margin-top: 20px;
            transition: all 0.2s ease;
        }

        .overlay-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 20px rgba(212, 168, 75, 0.5);
        }

        /* Instructions */
        #instructions {
            position: absolute;
            bottom: 100px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid var(--gold-dark);
            color: var(--parchment-dark);
            font-size: 12px;
            max-width: 300px;
            line-height: 1.6;
        }

        #instructions h3 {
            font-family: 'Cinzel', serif;
            color: var(--gold);
            margin-bottom: 8px;
        }

        #instructions kbd {
            background: rgba(212, 168, 75, 0.2);
            padding: 2px 6px;
            border-radius: 3px;
            border: 1px solid var(--gold-dark);
        }

        /* Age Display */
        #age-display {
            background: linear-gradient(180deg, rgba(153, 50, 204, 0.3) 0%, rgba(75, 0, 130, 0.4) 100%);
            border: 2px solid var(--gem-purple);
            border-radius: 8px;
            padding: 12px;
            text-align: center;
            margin-bottom: 10px;
        }

        .age-name {
            font-family: 'Cinzel', serif;
            font-size: 18px;
            font-weight: 900;
            color: var(--gold);
            text-shadow: 0 2px 8px rgba(212, 168, 75, 0.5);
            margin-bottom: 8px;
        }

        .age-advance-btn {
            width: 100%;
            padding: 8px 16px;
            font-family: 'Cinzel', serif;
            font-size: 12px;
            font-weight: 700;
            background: linear-gradient(180deg, var(--gem-purple) 0%, #4b0082 100%);
            border: 2px solid var(--gold);
            border-radius: 4px;
            color: #fff;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .age-advance-btn:hover:not(.disabled) {
            background: linear-gradient(180deg, #ba55d3 0%, var(--gem-purple) 100%);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(153, 50, 204, 0.4);
        }

        .age-advance-btn.disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        /* Upgrade Grid */
        .upgrade-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
        }

        .upgrade-btn {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 10px 6px;
            background: linear-gradient(180deg, rgba(34, 139, 34, 0.4) 0%, rgba(0, 100, 0, 0.5) 100%);
            border: 2px solid var(--food-green);
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .upgrade-btn:hover:not(.disabled):not(.maxed) {
            background: linear-gradient(180deg, rgba(50, 205, 50, 0.5) 0%, rgba(34, 139, 34, 0.6) 100%);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(34, 139, 34, 0.3);
        }

        .upgrade-btn.disabled {
            opacity: 0.5;
            cursor: not-allowed;
            border-color: #555;
        }

        .upgrade-btn.maxed {
            background: linear-gradient(180deg, rgba(212, 168, 75, 0.4) 0%, rgba(139, 105, 20, 0.5) 100%);
            border-color: var(--gold);
            cursor: default;
        }

        .upgrade-icon {
            font-size: 24px;
            margin-bottom: 2px;
        }

        .upgrade-name {
            font-family: 'Almendra', serif;
            font-size: 10px;
            color: var(--parchment);
            text-align: center;
        }

        .upgrade-level {
            font-family: 'Cinzel', serif;
            font-size: 11px;
            font-weight: 700;
            color: var(--gold);
            margin-top: 2px;
        }

        .upgrade-cost {
            font-size: 8px;
            color: var(--parchment-dark);
            margin-top: 2px;
        }

        .upgrade-btn.maxed .upgrade-cost {
            color: var(--gold);
        }

        /* Stats Display in Selection */
        .unit-stats-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 4px;
            margin-top: 4px;
        }

        .stat-item {
            display: flex;
            align-items: center;
            gap: 2px;
            font-size: 11px;
            color: var(--parchment-dark);
        }

        .stat-value {
            color: var(--gold);
            font-weight: bold;
        }

        .stat-bonus {
            color: #90EE90;
            font-size: 9px;
        }

        /* Cheat Console */
        #cheat-console {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 500px;
            max-height: 70vh;
            background: rgba(10, 5, 2, 0.98);
            border: 3px solid var(--gold);
            border-radius: 12px;
            display: none;
            flex-direction: column;
            z-index: 3000;
            box-shadow: 0 0 60px rgba(0,0,0,0.8);
        }

        #cheat-console.active {
            display: flex;
        }

        .console-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 16px;
            background: linear-gradient(180deg, var(--gold-dark) 0%, rgba(139, 105, 20, 0.8) 100%);
            border-radius: 8px 8px 0 0;
        }

        .console-title {
            font-family: 'Cinzel', serif;
            font-size: 16px;
            font-weight: 700;
            color: #fff;
        }

        .console-close {
            background: none;
            border: none;
            color: #fff;
            font-size: 20px;
            cursor: pointer;
        }

        .console-output {
            flex: 1;
            overflow-y: auto;
            padding: 12px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            color: #0f0;
            max-height: 300px;
            background: #000;
        }

        .console-output .cmd-input {
            color: #0ff;
        }

        .console-output .cmd-error {
            color: #f55;
        }

        .console-output .cmd-success {
            color: #5f5;
        }

        .console-input-area {
            display: flex;
            border-top: 1px solid var(--gold-dark);
        }

        .console-input-area span {
            padding: 12px;
            color: var(--gold);
            font-family: 'Courier New', monospace;
        }

        #console-input {
            flex: 1;
            background: rgba(0,0,0,0.8);
            border: none;
            color: #0f0;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            padding: 12px;
            outline: none;
        }

        .console-help {
            padding: 12px;
            background: rgba(212, 168, 75, 0.1);
            font-size: 11px;
            color: var(--parchment-dark);
            border-top: 1px solid var(--gold-dark);
        }

        /* Fog of War overlay */
        .fog-tile {
            position: absolute;
            background: #111;
            pointer-events: none;
        }

        /* Sound toggle */
        #sound-toggle {
            position: fixed;
            top: 70px;
            right: 300px;
            background: rgba(44, 24, 16, 0.9);
            border: 2px solid var(--gold-dark);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 20px;
            z-index: 100;
        }

        #sound-toggle:hover {
            border-color: var(--gold);
        }

        /* Multiplayer status */
        #mp-status {
            position: fixed;
            top: 70px;
            right: 350px;
            background: rgba(44, 24, 16, 0.9);
            border: 2px solid var(--gold-dark);
            border-radius: 20px;
            padding: 8px 16px;
            font-size: 12px;
            color: var(--parchment);
            z-index: 100;
            display: none;
        }

        #mp-status.connected {
            border-color: var(--food-green);
            color: #90EE90;
        }

        /* Tech tree panel */
        #tech-tree-btn {
            background: linear-gradient(180deg, rgba(70, 130, 180, 0.6) 0%, rgba(25, 55, 95, 0.8) 100%);
            border: 2px solid #4682B4;
            color: #fff;
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-family: 'Cinzel', serif;
            font-size: 12px;
            margin-top: 8px;
            width: 100%;
        }

        #tech-tree-btn:hover {
            background: linear-gradient(180deg, rgba(100, 160, 210, 0.7) 0%, rgba(70, 130, 180, 0.9) 100%);
        }

        #tech-tree-panel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 80%;
            max-width: 900px;
            max-height: 80vh;
            background: rgba(20, 10, 5, 0.98);
            border: 3px solid var(--gold);
            border-radius: 12px;
            display: none;
            flex-direction: column;
            z-index: 2500;
            overflow: hidden;
        }

        #tech-tree-panel.active {
            display: flex;
        }

        /* Main Menu Styles */
        #main-menu {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #0a0a15 0%, #1a1a2e 30%, #16213e 60%, #0f3460 100%);
            z-index: 5000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }

        #main-menu.hidden {
            display: none;
        }

        .menu-bg-decoration {
            position: absolute;
            width: 100%;
            height: 100%;
            background:
                radial-gradient(ellipse at 20% 80%, rgba(212, 168, 75, 0.1) 0%, transparent 50%),
                radial-gradient(ellipse at 80% 20%, rgba(139, 69, 19, 0.1) 0%, transparent 50%);
            pointer-events: none;
        }

        .menu-title {
            font-family: 'Cinzel', serif;
            font-size: 64px;
            font-weight: 900;
            color: var(--gold);
            text-shadow: 0 4px 20px rgba(212, 168, 75, 0.5), 0 0 60px rgba(212, 168, 75, 0.3);
            margin-bottom: 10px;
            text-align: center;
            z-index: 1;
        }

        .menu-subtitle {
            font-family: 'Almendra', serif;
            font-size: 20px;
            color: var(--parchment-dark);
            margin-bottom: 50px;
            letter-spacing: 4px;
            text-transform: uppercase;
            z-index: 1;
        }

        .menu-buttons {
            display: flex;
            flex-direction: column;
            gap: 15px;
            z-index: 1;
        }

        .menu-btn {
            font-family: 'Cinzel', serif;
            font-size: 22px;
            font-weight: 700;
            color: var(--parchment);
            background: linear-gradient(180deg, rgba(139, 69, 19, 0.7) 0%, rgba(70, 35, 10, 0.9) 100%);
            border: 3px solid var(--gold-dark);
            border-radius: 8px;
            padding: 18px 60px;
            cursor: pointer;
            transition: all 0.3s;
            min-width: 300px;
            text-align: center;
        }

        .menu-btn:hover {
            background: linear-gradient(180deg, rgba(212, 168, 75, 0.5) 0%, rgba(139, 69, 19, 0.9) 100%);
            border-color: var(--gold);
            transform: scale(1.02);
            box-shadow: 0 0 30px rgba(212, 168, 75, 0.3);
        }

        .menu-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .menu-version {
            position: absolute;
            bottom: 20px;
            right: 20px;
            font-size: 12px;
            color: var(--parchment-dark);
            opacity: 0.6;
        }

        /* New Game Setup Screen */
        #game-setup {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(10, 10, 21, 0.98);
            z-index: 5001;
            display: none;
            flex-direction: column;
            align-items: center;
            padding: 40px;
            overflow-y: auto;
        }

        #game-setup.active {
            display: flex;
        }

        .setup-title {
            font-family: 'Cinzel', serif;
            font-size: 36px;
            color: var(--gold);
            margin-bottom: 30px;
        }

        .setup-container {
            display: flex;
            gap: 40px;
            flex-wrap: wrap;
            justify-content: center;
            max-width: 1200px;
        }

        .setup-section {
            background: rgba(44, 24, 16, 0.8);
            border: 2px solid var(--gold-dark);
            border-radius: 12px;
            padding: 25px;
            min-width: 300px;
            max-width: 400px;
        }

        .setup-section-title {
            font-family: 'Cinzel', serif;
            font-size: 18px;
            color: var(--gold);
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 1px solid var(--gold-dark);
            text-align: center;
        }

        .setup-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            color: var(--parchment);
            font-size: 14px;
        }

        .setup-label {
            flex: 1;
        }

        .setup-select, .setup-input {
            font-family: 'Almendra', serif;
            font-size: 14px;
            padding: 8px 12px;
            background: rgba(0, 0, 0, 0.4);
            border: 2px solid var(--gold-dark);
            border-radius: 6px;
            color: var(--parchment);
            min-width: 150px;
        }

        .setup-select:focus, .setup-input:focus {
            border-color: var(--gold);
            outline: none;
        }

        .opponent-config {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 10px;
        }

        .opponent-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .opponent-name {
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .opponent-color {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 2px solid var(--parchment);
        }

        .map-preview {
            width: 100%;
            height: 150px;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid var(--gold-dark);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-top: 15px;
            font-size: 12px;
            color: var(--parchment-dark);
        }

        .setup-buttons {
            display: flex;
            gap: 20px;
            margin-top: 30px;
        }

        .setup-btn {
            font-family: 'Cinzel', serif;
            font-size: 18px;
            padding: 15px 40px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .setup-btn.primary {
            background: linear-gradient(180deg, rgba(34, 139, 34, 0.7) 0%, rgba(0, 100, 0, 0.9) 100%);
            border: 3px solid #228B22;
            color: white;
        }

        .setup-btn.primary:hover {
            background: linear-gradient(180deg, rgba(50, 205, 50, 0.7) 0%, rgba(34, 139, 34, 0.9) 100%);
            box-shadow: 0 0 20px rgba(34, 139, 34, 0.5);
        }

        .setup-btn.secondary {
            background: linear-gradient(180deg, rgba(139, 69, 19, 0.6) 0%, rgba(70, 35, 10, 0.8) 100%);
            border: 3px solid var(--gold-dark);
            color: var(--parchment);
        }

        .setup-btn.secondary:hover {
            border-color: var(--gold);
        }

        /* Save/Load Menu */
        #save-load-menu {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(20, 10, 5, 0.98);
            border: 3px solid var(--gold);
            border-radius: 12px;
            padding: 30px;
            z-index: 5002;
            min-width: 400px;
            max-width: 600px;
            display: none;
        }

        #save-load-menu.active {
            display: block;
        }

        .save-slot {
            background: rgba(0, 0, 0, 0.4);
            border: 2px solid var(--gold-dark);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 10px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .save-slot:hover {
            border-color: var(--gold);
            background: rgba(212, 168, 75, 0.1);
        }

        .save-slot.empty {
            opacity: 0.6;
            text-align: center;
            color: var(--parchment-dark);
        }

        .save-slot-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
        }

        .save-slot-name {
            font-family: 'Cinzel', serif;
            font-weight: bold;
            color: var(--gold);
        }

        .save-slot-date {
            font-size: 12px;
            color: var(--parchment-dark);
        }

        .save-slot-info {
            font-size: 12px;
            color: var(--parchment);
        }

        /* In-game Menu */
        #pause-menu {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(20, 10, 5, 0.98);
            border: 3px solid var(--gold);
            border-radius: 12px;
            padding: 30px;
            z-index: 4000;
            display: none;
            flex-direction: column;
            align-items: center;
            gap: 15px;
        }

        #pause-menu.active {
            display: flex;
        }

        .pause-title {
            font-family: 'Cinzel', serif;
            font-size: 28px;
            color: var(--gold);
            margin-bottom: 10px;
        }

        /* Diplomacy Panel */
        #diplomacy-panel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 80%;
            max-width: 700px;
            max-height: 80vh;
            background: rgba(20, 10, 5, 0.98);
            border: 3px solid var(--gold);
            border-radius: 12px;
            display: none;
            flex-direction: column;
            z-index: 2600;
            overflow: hidden;
        }

        #diplomacy-panel.active {
            display: flex;
        }

        .diplomacy-content {
            padding: 20px;
            overflow-y: auto;
        }

        .faction-card {
            background: rgba(0, 0, 0, 0.4);
            border: 2px solid var(--gold-dark);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
        }

        .faction-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 12px;
        }

        .faction-info {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .faction-color-badge {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            border: 2px solid var(--parchment);
        }

        .faction-name {
            font-family: 'Cinzel', serif;
            font-size: 16px;
            color: var(--parchment);
        }

        .faction-status {
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: bold;
            text-transform: uppercase;
        }

        .faction-status.war {
            background: #8B0000;
            color: #ff6b6b;
        }

        .faction-status.peace {
            background: #2E7D32;
            color: #90EE90;
        }

        .faction-status.allied {
            background: #1565C0;
            color: #64B5F6;
        }

        .faction-stats {
            display: flex;
            gap: 20px;
            margin-bottom: 12px;
            font-size: 12px;
            color: var(--parchment-dark);
        }

        .faction-actions {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .diplo-btn {
            font-family: 'Almendra', serif;
            font-size: 12px;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .diplo-btn.war {
            background: linear-gradient(180deg, #8B0000 0%, #4a0000 100%);
            border: 2px solid #DC143C;
            color: #fff;
        }

        .diplo-btn.war:hover {
            background: linear-gradient(180deg, #a00000 0%, #600000 100%);
        }

        .diplo-btn.peace {
            background: linear-gradient(180deg, #2E7D32 0%, #1B5E20 100%);
            border: 2px solid #4CAF50;
            color: #fff;
        }

        .diplo-btn.peace:hover {
            background: linear-gradient(180deg, #388E3C 0%, #2E7D32 100%);
        }

        .diplo-btn.alliance {
            background: linear-gradient(180deg, #1565C0 0%, #0D47A1 100%);
            border: 2px solid #2196F3;
            color: #fff;
        }

        .diplo-btn.alliance:hover {
            background: linear-gradient(180deg, #1976D2 0%, #1565C0 100%);
        }

        .diplo-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .tribute-input {
            width: 80px;
            padding: 6px;
            background: rgba(0, 0, 0, 0.4);
            border: 1px solid var(--gold-dark);
            border-radius: 4px;
            color: var(--parchment);
            font-size: 12px;
        }

        .pending-offer {
            background: rgba(212, 168, 75, 0.2);
            border: 2px solid var(--gold);
            border-radius: 8px;
            padding: 10px;
            margin-top: 10px;
        }

        .pending-offer-text {
            font-size: 13px;
            color: var(--gold);
            margin-bottom: 8px;
        }

        #diplomacy-btn {
            background: linear-gradient(180deg, rgba(100, 100, 180, 0.6) 0%, rgba(50, 50, 100, 0.8) 100%);
            border: 2px solid #6464B4;
            color: #fff;
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-family: 'Cinzel', serif;
            font-size: 12px;
            margin-top: 8px;
            width: 100%;
        }

        #diplomacy-btn:hover {
            background: linear-gradient(180deg, rgba(130, 130, 210, 0.7) 0%, rgba(100, 100, 180, 0.9) 100%);
        }

        .tech-tree-content {
            display: flex;
            gap: 20px;
            padding: 20px;
            overflow-x: auto;
        }

        .tech-age-column {
            min-width: 200px;
            background: rgba(0,0,0,0.3);
            border-radius: 8px;
            padding: 12px;
        }

        .tech-age-title {
            font-family: 'Cinzel', serif;
            font-size: 14px;
            color: var(--gold);
            text-align: center;
            padding-bottom: 8px;
            border-bottom: 1px solid var(--gold-dark);
            margin-bottom: 12px;
        }

        .tech-item {
            background: rgba(139, 69, 19, 0.4);
            border: 2px solid var(--gold-dark);
            border-radius: 6px;
            padding: 10px;
            margin-bottom: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .tech-item:hover:not(.locked):not(.researched) {
            border-color: var(--gold);
            background: rgba(212, 168, 75, 0.3);
        }

        .tech-item.locked {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .tech-item.researched {
            background: rgba(34, 139, 34, 0.4);
            border-color: var(--food-green);
        }

        .tech-item-name {
            font-family: 'Cinzel', serif;
            font-size: 12px;
            color: var(--parchment);
            margin-bottom: 4px;
        }

        .tech-item-desc {
            font-size: 10px;
            color: var(--parchment-dark);
        }

        .tech-item-cost {
            font-size: 9px;
            color: var(--gold);
            margin-top: 4px;
        }
    </style>
</head>
<body>
    <!-- Main Menu -->
    <div id="main-menu">
        <div class="menu-bg-decoration"></div>
        <div class="menu-title">‚öîÔ∏è Realm of Conquest ‚öîÔ∏è</div>
        <div class="menu-subtitle">A Real-Time Strategy Game</div>
        <div class="menu-buttons">
            <button class="menu-btn" onclick="showGameSetup()">üéÆ New Game</button>
            <button class="menu-btn" id="continue-btn" onclick="showLoadMenu()" disabled>üìÇ Continue</button>
            <button class="menu-btn" onclick="showOptions()">‚öôÔ∏è Options</button>
        </div>
        <div class="menu-version">Version 2.0 | Press ` for console</div>
    </div>

    <!-- Game Setup Screen -->
    <div id="game-setup">
        <div class="setup-title">‚öîÔ∏è New Game Setup ‚öîÔ∏è</div>
        <div class="setup-container">
            <!-- Map Settings -->
            <div class="setup-section">
                <div class="setup-section-title">üó∫Ô∏è Map Settings</div>
                <div class="setup-row">
                    <span class="setup-label">Map Size:</span>
                    <select class="setup-select" id="map-size" onchange="updateMapPreview()">
                        <option value="small">Small (40x30)</option>
                        <option value="medium" selected>Medium (60x40)</option>
                        <option value="large">Large (80x60)</option>
                        <option value="huge">Huge (120x80)</option>
                    </select>
                </div>
                <div class="setup-row">
                    <span class="setup-label">Map Type:</span>
                    <select class="setup-select" id="map-type" onchange="updateMapPreview()">
                        <option value="continental" selected>Continental</option>
                        <option value="islands">Islands</option>
                        <option value="desert">Desert</option>
                        <option value="forest">Dense Forest</option>
                        <option value="highlands">Highlands</option>
                        <option value="archipelago">Archipelago</option>
                    </select>
                </div>
                <div class="setup-row">
                    <span class="setup-label">Resources:</span>
                    <select class="setup-select" id="map-resources">
                        <option value="scarce">Scarce</option>
                        <option value="standard" selected>Standard</option>
                        <option value="abundant">Abundant</option>
                    </select>
                </div>
                <div class="map-preview" id="map-preview">
                    Map preview will appear here
                </div>
            </div>

            <!-- Opponent Settings -->
            <div class="setup-section">
                <div class="setup-section-title">üë• Opponents</div>
                <div class="setup-row">
                    <span class="setup-label">Number of Opponents:</span>
                    <select class="setup-select" id="num-opponents" onchange="updateOpponentList()">
                        <option value="1" selected>1 Opponent</option>
                        <option value="2">2 Opponents</option>
                        <option value="3">3 Opponents</option>
                        <option value="4">4 Opponents</option>
                        <option value="5">5 Opponents</option>
                        <option value="6">6 Opponents</option>
                        <option value="7">7 Opponents</option>
                    </select>
                </div>
                <div id="opponent-list">
                    <!-- Generated by JS -->
                </div>
            </div>

            <!-- Player Settings -->
            <div class="setup-section">
                <div class="setup-section-title">üë§ Your Kingdom</div>
                <div class="setup-row">
                    <span class="setup-label">Kingdom Name:</span>
                    <input type="text" class="setup-input" id="player-name" value="Your Kingdom" maxlength="20">
                </div>
                <div class="setup-row">
                    <span class="setup-label">Starting Age:</span>
                    <select class="setup-select" id="starting-age">
                        <option value="0" selected>Stone Age</option>
                        <option value="1">Bronze Age</option>
                        <option value="2">Iron Age</option>
                    </select>
                </div>
                <div class="setup-row">
                    <span class="setup-label">Starting Resources:</span>
                    <select class="setup-select" id="starting-resources">
                        <option value="low">Low</option>
                        <option value="standard" selected>Standard</option>
                        <option value="high">High</option>
                        <option value="post-imperial">Post-Imperial</option>
                    </select>
                </div>
            </div>
        </div>
        <div class="setup-buttons">
            <button class="setup-btn secondary" onclick="hideGameSetup()">‚Üê Back</button>
            <button class="setup-btn primary" onclick="startNewGame()">‚öîÔ∏è Start Battle!</button>
        </div>
    </div>

    <!-- Save/Load Menu -->
    <div id="save-load-menu">
        <div class="setup-section-title" id="save-load-title">üíæ Save/Load Game</div>
        <div id="save-slots">
            <!-- Generated by JS -->
        </div>
        <div class="setup-buttons" style="justify-content: center;">
            <button class="setup-btn secondary" onclick="hideSaveLoadMenu()">Close</button>
        </div>
    </div>

    <!-- Pause Menu -->
    <div id="pause-menu">
        <div class="pause-title">‚è∏Ô∏è Game Paused</div>
        <button class="menu-btn" onclick="resumeGame()">‚ñ∂Ô∏è Resume</button>
        <button class="menu-btn" onclick="showSaveMenu()">üíæ Save Game</button>
        <button class="menu-btn" onclick="showLoadMenuInGame()">üìÇ Load Game</button>
        <button class="menu-btn" onclick="showOptionsInGame()">‚öôÔ∏è Options</button>
        <button class="menu-btn" onclick="returnToMainMenu()">üè† Main Menu</button>
    </div>

    <div id="game-container" class="hidden">
        <!-- Resource Bar -->
        <div id="resource-bar">
            <div class="resource" data-resource="food">
                <div class="resource-icon">üåæ</div>
                <div class="resource-amount" id="food-amount">200</div>
                <div class="resource-rate" id="food-rate">+0/s</div>
            </div>
            <div class="resource" data-resource="wood">
                <div class="resource-icon">ü™µ</div>
                <div class="resource-amount" id="wood-amount">200</div>
                <div class="resource-rate" id="wood-rate">+0/s</div>
            </div>
            <div class="resource" data-resource="stone">
                <div class="resource-icon">ü™®</div>
                <div class="resource-amount" id="stone-amount">100</div>
                <div class="resource-rate" id="stone-rate">+0/s</div>
            </div>
            <div class="resource" data-resource="gold">
                <div class="resource-icon">ü™ô</div>
                <div class="resource-amount" id="gold-amount">100</div>
                <div class="resource-rate" id="gold-rate">+0/s</div>
            </div>
            <div class="resource" data-resource="gems">
                <div class="resource-icon">üíé</div>
                <div class="resource-amount" id="gems-amount">0</div>
                <div class="resource-rate" id="gems-rate">+0/s</div>
            </div>
            <div class="resource" data-resource="population">
                <div class="resource-icon">üë•</div>
                <div class="resource-amount" id="pop-amount">0/10</div>
            </div>
        </div>

        <!-- Main Game Area -->
        <div id="main-area">
            <canvas id="game-canvas"></canvas>

            <!-- Build Panel -->
            <div id="build-panel">
                <!-- Age/Tech Display -->
                <div id="age-display">
                    <div class="age-name" id="current-age">Stone Age</div>
                    <button class="age-advance-btn" id="advance-age-btn" onclick="advanceAge()">
                        Advance Age
                    </button>
                    <button id="tech-tree-btn" onclick="toggleTechTree()">üìú View Tech Tree</button>
                    <button id="diplomacy-btn" onclick="toggleDiplomacy()">ü§ù Diplomacy (G)</button>
                </div>

                <!-- Upgrades Section -->
                <div class="build-category">
                    <div class="category-title">‚¨ÜÔ∏è Military Upgrades</div>
                    <div class="upgrade-grid" id="upgrade-grid">
                        <div class="upgrade-btn" data-upgrade="attack" onclick="applyUpgrade('attack')">
                            <div class="upgrade-icon">‚öîÔ∏è</div>
                            <div class="upgrade-name">Attack</div>
                            <div class="upgrade-level" id="attack-level">Lv.0</div>
                            <div class="upgrade-cost" id="attack-cost">100üåæ 50ü™ô</div>
                        </div>
                        <div class="upgrade-btn" data-upgrade="defense" onclick="applyUpgrade('defense')">
                            <div class="upgrade-icon">üõ°Ô∏è</div>
                            <div class="upgrade-name">Defense</div>
                            <div class="upgrade-level" id="defense-level">Lv.0</div>
                            <div class="upgrade-cost" id="defense-cost">100üåæ 75ü™®</div>
                        </div>
                        <div class="upgrade-btn" data-upgrade="hp" onclick="applyUpgrade('hp')">
                            <div class="upgrade-icon">‚ù§Ô∏è</div>
                            <div class="upgrade-name">Vitality</div>
                            <div class="upgrade-level" id="hp-level">Lv.0</div>
                            <div class="upgrade-cost" id="hp-cost">150üåæ 100ü™µ</div>
                        </div>
                        <div class="upgrade-btn" data-upgrade="speed" onclick="applyUpgrade('speed')">
                            <div class="upgrade-icon">üí®</div>
                            <div class="upgrade-name">Speed</div>
                            <div class="upgrade-level" id="speed-level">Lv.0</div>
                            <div class="upgrade-cost" id="speed-cost">150ü™ô 5üíé</div>
                        </div>
                    </div>
                </div>

                <div class="panel-header">‚öîÔ∏è BUILD ‚öîÔ∏è</div>
                
                <div class="build-category">
                    <div class="category-title">üèõÔ∏è Core Buildings</div>
                    <div class="build-grid">
                        <div class="build-btn" data-building="townCenter" title="Town Center">
                            <div class="build-icon">üèõÔ∏è</div>
                            <div class="build-name">Town Center</div>
                            <div class="build-cost">400ü™µ 200ü™®</div>
                        </div>
                        <div class="build-btn" data-building="house" title="House">
                            <div class="build-icon">üè†</div>
                            <div class="build-name">House</div>
                            <div class="build-cost">50ü™µ</div>
                        </div>
                    </div>
                </div>

                <div class="build-category">
                    <div class="category-title">‚õèÔ∏è Resource Buildings</div>
                    <div class="build-grid">
                        <div class="build-btn" data-building="farm" title="Farm">
                            <div class="build-icon">üåæ</div>
                            <div class="build-name">Farm</div>
                            <div class="build-cost">60ü™µ</div>
                        </div>
                        <div class="build-btn" data-building="lumberMill" title="Lumber Mill">
                            <div class="build-icon">ü™ì</div>
                            <div class="build-name">Lumber Mill</div>
                            <div class="build-cost">100ü™µ</div>
                        </div>
                        <div class="build-btn" data-building="quarry" title="Quarry">
                            <div class="build-icon">‚õèÔ∏è</div>
                            <div class="build-name">Quarry</div>
                            <div class="build-cost">100ü™µ 50ü™®</div>
                        </div>
                        <div class="build-btn" data-building="mine" title="Gold Mine">
                            <div class="build-icon">‚öíÔ∏è</div>
                            <div class="build-name">Gold Mine</div>
                            <div class="build-cost">150ü™µ 100ü™®</div>
                        </div>
                        <div class="build-btn" data-building="gemMine" title="Gem Mine">
                            <div class="build-icon">üíé</div>
                            <div class="build-name">Gem Mine</div>
                            <div class="build-cost">200ü™µ 150ü™® 50ü™ô</div>
                        </div>
                    </div>
                </div>

                <div class="build-category">
                    <div class="category-title">‚öîÔ∏è Military Buildings</div>
                    <div class="build-grid">
                        <div class="build-btn" data-building="barracks" title="Barracks">
                            <div class="build-icon">üè∞</div>
                            <div class="build-name">Barracks</div>
                            <div class="build-cost">150ü™µ 100ü™®</div>
                        </div>
                        <div class="build-btn" data-building="archeryRange" title="Archery Range">
                            <div class="build-icon">üèπ</div>
                            <div class="build-name">Archery Range</div>
                            <div class="build-cost">175ü™µ 75ü™®</div>
                        </div>
                        <div class="build-btn" data-building="stable" title="Stable">
                            <div class="build-icon">üê¥</div>
                            <div class="build-name">Stable</div>
                            <div class="build-cost">200ü™µ 100ü™®</div>
                        </div>
                        <div class="build-btn" data-building="siegeWorkshop" title="Siege Workshop">
                            <div class="build-icon">üîß</div>
                            <div class="build-name">Siege Works</div>
                            <div class="build-cost">300ü™µ 200ü™® 100ü™ô</div>
                        </div>
                    </div>
                </div>

                <div class="build-category">
                    <div class="category-title">üõ°Ô∏è Defense Buildings</div>
                    <div class="build-grid">
                        <div class="build-btn" data-building="wall" title="Wall">
                            <div class="build-icon">üß±</div>
                            <div class="build-name">Wall</div>
                            <div class="build-cost">20ü™®</div>
                        </div>
                        <div class="build-btn" data-building="tower" title="Tower">
                            <div class="build-icon">üóº</div>
                            <div class="build-name">Tower</div>
                            <div class="build-cost">100ü™® 50ü™ô</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Bottom Info Bar -->
        <div id="info-bar">
            <div id="selection-info">
                <div class="selection-portrait" id="sel-portrait">-</div>
                <div class="selection-details">
                    <div class="selection-name" id="sel-name">No Selection</div>
                    <div class="selection-stats" id="sel-stats">Click on a building or unit</div>
                </div>
            </div>
            <div id="unit-actions"></div>
            <div id="minimap-container">
                <canvas id="minimap"></canvas>
            </div>
        </div>
    </div>

    <div id="messages"></div>
    <div id="selection-box"></div>

    <div id="instructions">
        <h3>üéÆ Controls</h3>
        <p>
            <kbd>Left Click</kbd> Select / Place<br>
            <kbd>Right Click</kbd> Move / Attack<br>
            <kbd>WASD</kbd> Pan camera<br>
            <kbd>`</kbd> Cheat Console<br>
            <kbd>T</kbd> Tech Tree<br>
            <kbd>Esc</kbd> Cancel
        </p>
        <h3>üéØ Features</h3>
        <p>
            A* Pathfinding | Smart AI<br>
            Tech Tree | Fog of War<br>
            Sound FX | Multiplayer Ready
        </p>
    </div>

    <div id="game-overlay">
        <div class="overlay-content">
            <div class="overlay-title" id="overlay-title">Victory!</div>
            <button class="overlay-btn" onclick="location.reload()">Play Again</button>
        </div>
    </div>

    <!-- Cheat Console -->
    <div id="cheat-console">
        <div class="console-header">
            <span class="console-title">üéÆ Developer Console</span>
            <button class="console-close" onclick="toggleConsole()">&times;</button>
        </div>
        <div class="console-output" id="console-output">
            <div>Welcome to the Developer Console!</div>
            <div>Type 'help' for available commands.</div>
        </div>
        <div class="console-input-area">
            <span>&gt;</span>
            <input type="text" id="console-input" placeholder="Enter command..." autocomplete="off">
        </div>
        <div class="console-help">
            Press <kbd>`</kbd> or <kbd>~</kbd> to toggle console | <kbd>Enter</kbd> to execute | <kbd>‚Üë‚Üì</kbd> command history
        </div>
    </div>

    <!-- Sound Toggle -->
    <div id="sound-toggle" onclick="toggleSound()">üîä</div>

    <!-- Multiplayer Status -->
    <div id="mp-status">Offline</div>

    <!-- Tech Tree Panel -->
    <div id="tech-tree-panel">
        <div class="console-header">
            <span class="console-title">üìú Technology Tree</span>
            <button class="console-close" onclick="toggleTechTree()">&times;</button>
        </div>
        <div class="tech-tree-content" id="tech-tree-content">
            <!-- Generated by JS -->
        </div>
    </div>

    <!-- Diplomacy Panel -->
    <div id="diplomacy-panel">
        <div class="console-header">
            <span class="console-title">ü§ù Diplomacy</span>
            <button class="console-close" onclick="toggleDiplomacy()">&times;</button>
        </div>
        <div class="diplomacy-content" id="diplomacy-content">
            <!-- Generated by JS -->
        </div>
    </div>

    <script>
        // ============================================
        // GAME CONFIGURATION
        // ============================================
        let CONFIG = {
            TILE_SIZE: 40,
            MAP_WIDTH: 60,
            MAP_HEIGHT: 40,
            CAMERA_SPEED: 15,
            RESOURCE_TICK: 1000, // ms
        };

        // ============================================
        // GAME SETTINGS (configured in setup)
        // ============================================
        const GAME_SETTINGS = {
            mapSize: 'medium',
            mapType: 'continental',
            mapResources: 'standard',
            numOpponents: 1,
            opponents: [{ name: 'Enemy Kingdom', difficulty: 'medium', color: '#DC143C' }],
            playerName: 'Your Kingdom',
            startingAge: 0,
            startingResources: 'standard',
            gameStarted: false,
            gamePaused: false
        };

        // Map size configurations
        const MAP_SIZES = {
            small: { width: 40, height: 30 },
            medium: { width: 60, height: 40 },
            large: { width: 80, height: 60 },
            huge: { width: 120, height: 80 }
        };

        // Starting resource configurations
        const STARTING_RESOURCES = {
            low: { food: 100, wood: 100, stone: 50, gold: 50, gems: 0 },
            standard: { food: 200, wood: 200, stone: 100, gold: 100, gems: 0 },
            high: { food: 500, wood: 500, stone: 300, gold: 300, gems: 20 },
            'post-imperial': { food: 2000, wood: 2000, stone: 1500, gold: 1500, gems: 100 }
        };

        // AI opponent colors
        const OPPONENT_COLORS = [
            '#DC143C', // Crimson Red
            '#FF8C00', // Dark Orange
            '#9932CC', // Dark Orchid
            '#008B8B', // Dark Cyan
            '#8B4513', // Saddle Brown
            '#2F4F4F', // Dark Slate Gray
            '#800080'  // Purple
        ];

        const OPPONENT_NAMES = [
            'The Red Empire', 'The Orange Legion', 'The Purple Realm',
            'The Teal Dynasty', 'The Brown Horde', 'The Gray Alliance', 'The Violet Kingdom'
        ];

        // ============================================
        // DIPLOMACY SYSTEM
        // ============================================
        const DIPLOMATIC_STATES = {
            WAR: 'war',
            PEACE: 'peace',
            ALLIED: 'allied'
        };

        // Diplomacy relations - tracks player's relation with each AI
        const diplomacy = {
            relations: {}, // { aiId: { state: 'peace', turnsAtPeace: 0, tributePaid: 0 } }

            initialize() {
                this.relations = {};
                for (const ai of aiPlayers) {
                    this.relations[ai.id] = {
                        state: DIPLOMATIC_STATES.PEACE, // Start at peace
                        turnsAtPeace: 0,
                        turnsAtWar: 0,
                        tributeReceived: 0,
                        tributePaid: 0,
                        lastWarDeclaration: 0
                    };
                }
            },

            getRelation(aiId) {
                return this.relations[aiId]?.state || DIPLOMATIC_STATES.PEACE;
            },

            isAtWar(aiId) {
                return this.getRelation(aiId) === DIPLOMATIC_STATES.WAR;
            },

            isAllied(aiId) {
                return this.getRelation(aiId) === DIPLOMATIC_STATES.ALLIED;
            },

            declareWar(aiId) {
                if (!this.relations[aiId]) return;
                const prevState = this.relations[aiId].state;
                this.relations[aiId].state = DIPLOMATIC_STATES.WAR;
                this.relations[aiId].turnsAtWar = 0;
                this.relations[aiId].lastWarDeclaration = Date.now();

                const ai = aiPlayers.find(a => a.id === aiId);
                if (ai) {
                    showMessage(`You declared WAR on ${ai.name}!`, 'error');
                    soundSystem.play('battle');
                }
                updateDiplomacyUI();
            },

            offerPeace(aiId, tributeAmount = 0) {
                if (!this.relations[aiId]) return false;
                if (this.relations[aiId].state !== DIPLOMATIC_STATES.WAR) return false;

                const ai = aiPlayers.find(a => a.id === aiId);
                if (!ai) return false;

                // AI decides whether to accept peace based on difficulty and tribute
                const acceptChance = this.calculatePeaceAcceptance(ai, tributeAmount);

                if (Math.random() < acceptChance) {
                    // Deduct tribute
                    if (tributeAmount > 0) {
                        if (gameState.resources.gold < tributeAmount) {
                            showMessage('Not enough gold for tribute!', 'error');
                            return false;
                        }
                        gameState.resources.gold -= tributeAmount;
                        ai.resources.gold += tributeAmount;
                        this.relations[aiId].tributePaid += tributeAmount;
                    }

                    this.relations[aiId].state = DIPLOMATIC_STATES.PEACE;
                    this.relations[aiId].turnsAtPeace = 0;
                    showMessage(`${ai.name} accepted your peace offer!`, 'success');
                    updateDiplomacyUI();
                    return true;
                } else {
                    showMessage(`${ai.name} rejected your peace offer!`, 'error');
                    return false;
                }
            },

            calculatePeaceAcceptance(ai, tribute) {
                let chance = 0.3; // Base 30% chance

                // More tribute = higher chance
                chance += Math.min(tribute / 500, 0.4); // Up to +40% for 500+ gold

                // Easier difficulty = more likely to accept
                if (ai.difficulty === 'easy') chance += 0.2;
                if (ai.difficulty === 'hard') chance -= 0.2;

                // If AI is losing (few units), more likely to accept
                if (ai.units.length < 3) chance += 0.3;

                // If been at war long, more likely to accept
                const warDuration = (Date.now() - this.relations[ai.id].lastWarDeclaration) / 60000;
                chance += Math.min(warDuration / 10, 0.2);

                return Math.min(Math.max(chance, 0.1), 0.9);
            },

            offerAlliance(aiId, tributeAmount = 0) {
                if (!this.relations[aiId]) return false;
                if (this.relations[aiId].state === DIPLOMATIC_STATES.WAR) {
                    showMessage('Cannot form alliance while at war!', 'error');
                    return false;
                }

                const ai = aiPlayers.find(a => a.id === aiId);
                if (!ai) return false;

                // Alliance requires significant tribute and good relations
                const minTribute = 200;
                if (tributeAmount < minTribute) {
                    showMessage(`Alliance requires at least ${minTribute} gold tribute!`, 'error');
                    return false;
                }

                if (gameState.resources.gold < tributeAmount) {
                    showMessage('Not enough gold for tribute!', 'error');
                    return false;
                }

                // Acceptance based on difficulty
                let acceptChance = 0.4 + (tributeAmount - minTribute) / 1000;
                if (ai.difficulty === 'easy') acceptChance += 0.3;
                if (ai.difficulty === 'hard') acceptChance -= 0.2;

                // Longer peace = higher chance
                acceptChance += Math.min(this.relations[aiId].turnsAtPeace / 100, 0.2);

                if (Math.random() < acceptChance) {
                    gameState.resources.gold -= tributeAmount;
                    ai.resources.gold += tributeAmount;
                    this.relations[aiId].state = DIPLOMATIC_STATES.ALLIED;
                    this.relations[aiId].tributePaid += tributeAmount;
                    showMessage(`${ai.name} is now your ALLY!`, 'success');
                    updateDiplomacyUI();
                    return true;
                } else {
                    showMessage(`${ai.name} rejected your alliance offer!`, 'error');
                    return false;
                }
            },

            breakAlliance(aiId) {
                if (!this.relations[aiId]) return;
                if (this.relations[aiId].state !== DIPLOMATIC_STATES.ALLIED) return;

                this.relations[aiId].state = DIPLOMATIC_STATES.PEACE;
                const ai = aiPlayers.find(a => a.id === aiId);
                if (ai) {
                    showMessage(`Alliance with ${ai.name} has ended.`, 'info');
                }
                updateDiplomacyUI();
            },

            // Called by AI to declare war on player
            aiDeclareWar(aiId) {
                if (!this.relations[aiId]) return;
                if (this.relations[aiId].state === DIPLOMATIC_STATES.WAR) return;

                this.relations[aiId].state = DIPLOMATIC_STATES.WAR;
                this.relations[aiId].turnsAtWar = 0;
                this.relations[aiId].lastWarDeclaration = Date.now();

                const ai = aiPlayers.find(a => a.id === aiId);
                if (ai) {
                    showMessage(`${ai.name} has declared WAR on you!`, 'error');
                    soundSystem.play('battle');
                }
                updateDiplomacyUI();
            },

            // Called by AI to offer peace
            aiOfferPeace(aiId, tributeAmount = 0) {
                if (!this.relations[aiId]) return;
                if (this.relations[aiId].state !== DIPLOMATIC_STATES.WAR) return;

                const ai = aiPlayers.find(a => a.id === aiId);
                if (!ai) return;

                // Store pending peace offer
                this.relations[aiId].pendingPeaceOffer = {
                    tribute: tributeAmount,
                    timestamp: Date.now()
                };

                showMessage(`${ai.name} offers peace with ${tributeAmount} gold tribute!`, 'info');
                updateDiplomacyUI();
            },

            acceptAIPeaceOffer(aiId) {
                if (!this.relations[aiId]?.pendingPeaceOffer) return;

                const ai = aiPlayers.find(a => a.id === aiId);
                const tribute = this.relations[aiId].pendingPeaceOffer.tribute;

                gameState.resources.gold += tribute;
                this.relations[aiId].tributeReceived += tribute;
                this.relations[aiId].state = DIPLOMATIC_STATES.PEACE;
                this.relations[aiId].turnsAtPeace = 0;
                delete this.relations[aiId].pendingPeaceOffer;

                showMessage(`Peace with ${ai.name}! Received ${tribute} gold.`, 'success');
                updateDiplomacyUI();
            },

            rejectAIPeaceOffer(aiId) {
                if (!this.relations[aiId]?.pendingPeaceOffer) return;
                delete this.relations[aiId].pendingPeaceOffer;

                const ai = aiPlayers.find(a => a.id === aiId);
                showMessage(`Rejected peace offer from ${ai.name}.`, 'info');
                updateDiplomacyUI();
            },

            update(deltaTime) {
                // Update peace/war timers
                for (const aiId in this.relations) {
                    const rel = this.relations[aiId];
                    if (rel.state === DIPLOMATIC_STATES.PEACE || rel.state === DIPLOMATIC_STATES.ALLIED) {
                        rel.turnsAtPeace += deltaTime / 1000;
                    } else if (rel.state === DIPLOMATIC_STATES.WAR) {
                        rel.turnsAtWar += deltaTime / 1000;
                    }
                }
            }
        };

        // ============================================
        // DIPLOMACY UI FUNCTIONS
        // ============================================
        function toggleDiplomacy() {
            const panel = document.getElementById('diplomacy-panel');
            panel.classList.toggle('active');
            if (panel.classList.contains('active')) {
                updateDiplomacyUI();
            }
        }

        function updateDiplomacyUI() {
            const content = document.getElementById('diplomacy-content');
            if (!content) return;

            let html = '';

            for (const ai of aiPlayers) {
                const rel = diplomacy.relations[ai.id];
                if (!rel) continue;

                const statusClass = rel.state;
                const statusText = rel.state === DIPLOMATIC_STATES.WAR ? '‚öîÔ∏è At War' :
                                  rel.state === DIPLOMATIC_STATES.ALLIED ? 'ü§ù Allied' : '‚òÆÔ∏è Peace';

                html += `
                    <div class="faction-card">
                        <div class="faction-header">
                            <div class="faction-info">
                                <div class="faction-color-badge" style="background: ${ai.color}"></div>
                                <div>
                                    <div class="faction-name">${ai.name}</div>
                                    <div style="font-size: 11px; color: var(--parchment-dark);">
                                        Difficulty: ${ai.difficulty.charAt(0).toUpperCase() + ai.difficulty.slice(1)}
                                    </div>
                                </div>
                            </div>
                            <span class="faction-status ${statusClass}">${statusText}</span>
                        </div>
                        <div class="faction-stats">
                            <span>üè∞ ${ai.buildings.length} buildings</span>
                            <span>‚öîÔ∏è ${ai.units.length} units</span>
                            <span>üí∞ ~${Math.floor(ai.resources.gold)} gold</span>
                        </div>
                        <div class="faction-actions">
                            ${getDiplomacyActions(ai, rel)}
                        </div>
                        ${getPendingOfferUI(ai, rel)}
                    </div>
                `;
            }

            if (aiPlayers.length === 0) {
                html = '<p style="color: var(--parchment-dark); text-align: center;">No factions to negotiate with.</p>';
            }

            content.innerHTML = html;
        }

        function getDiplomacyActions(ai, rel) {
            let actions = '';

            if (rel.state === DIPLOMATIC_STATES.PEACE) {
                actions += `
                    <button class="diplo-btn war" onclick="diplomacy.declareWar(${ai.id})">
                        ‚öîÔ∏è Declare War
                    </button>
                    <span style="display: flex; align-items: center; gap: 5px;">
                        <input type="number" class="tribute-input" id="alliance-tribute-${ai.id}"
                               value="200" min="200" step="50" placeholder="Gold">
                        <button class="diplo-btn alliance" onclick="offerAlliance(${ai.id})">
                            ü§ù Offer Alliance
                        </button>
                    </span>
                `;
            } else if (rel.state === DIPLOMATIC_STATES.WAR) {
                actions += `
                    <span style="display: flex; align-items: center; gap: 5px;">
                        <input type="number" class="tribute-input" id="peace-tribute-${ai.id}"
                               value="0" min="0" step="50" placeholder="Gold">
                        <button class="diplo-btn peace" onclick="offerPeace(${ai.id})">
                            ‚òÆÔ∏è Offer Peace
                        </button>
                    </span>
                `;
            } else if (rel.state === DIPLOMATIC_STATES.ALLIED) {
                actions += `
                    <button class="diplo-btn war" onclick="diplomacy.breakAlliance(${ai.id}); diplomacy.declareWar(${ai.id})">
                        ‚öîÔ∏è Break Alliance & Declare War
                    </button>
                    <button class="diplo-btn" style="background: #555; border-color: #777; color: #ccc;"
                            onclick="diplomacy.breakAlliance(${ai.id})">
                        End Alliance
                    </button>
                `;
            }

            return actions;
        }

        function getPendingOfferUI(ai, rel) {
            if (!rel.pendingPeaceOffer) return '';

            return `
                <div class="pending-offer">
                    <div class="pending-offer-text">
                        ${ai.name} offers peace with ${rel.pendingPeaceOffer.tribute} gold tribute!
                    </div>
                    <button class="diplo-btn peace" onclick="diplomacy.acceptAIPeaceOffer(${ai.id})">
                        ‚úì Accept
                    </button>
                    <button class="diplo-btn war" onclick="diplomacy.rejectAIPeaceOffer(${ai.id})">
                        ‚úó Reject
                    </button>
                </div>
            `;
        }

        function offerPeace(aiId) {
            const tribute = parseInt(document.getElementById(`peace-tribute-${aiId}`)?.value) || 0;
            diplomacy.offerPeace(aiId, tribute);
        }

        function offerAlliance(aiId) {
            const tribute = parseInt(document.getElementById(`alliance-tribute-${aiId}`)?.value) || 200;
            diplomacy.offerAlliance(aiId, tribute);
        }

        // ============================================
        // MOUSE EDGE SCROLLING
        // ============================================
        const edgeScroll = {
            enabled: true,
            edgeSize: 30, // pixels from edge to trigger scroll
            scrollSpeed: 12,
            currentMouseX: 0,
            currentMouseY: 0
        };

        function updateEdgeScrolling() {
            if (!edgeScroll.enabled || !GAME_SETTINGS.gameStarted || GAME_SETTINGS.gamePaused) return;

            const canvas = document.getElementById('game-canvas');
            if (!canvas) return;

            const rect = canvas.getBoundingClientRect();
            const mouseX = edgeScroll.currentMouseX;
            const mouseY = edgeScroll.currentMouseY;

            // Check if mouse is within canvas bounds
            if (mouseX < rect.left || mouseX > rect.right || mouseY < rect.top || mouseY > rect.bottom) {
                return;
            }

            const relX = mouseX - rect.left;
            const relY = mouseY - rect.top;
            const speed = edgeScroll.scrollSpeed;

            // Scroll left
            if (relX < edgeScroll.edgeSize) {
                gameState.camera.x = Math.max(0, gameState.camera.x - speed);
            }
            // Scroll right
            if (relX > rect.width - edgeScroll.edgeSize) {
                gameState.camera.x = Math.min(CONFIG.MAP_WIDTH * CONFIG.TILE_SIZE - canvas.width, gameState.camera.x + speed);
            }
            // Scroll up
            if (relY < edgeScroll.edgeSize) {
                gameState.camera.y = Math.max(0, gameState.camera.y - speed);
            }
            // Scroll down
            if (relY > rect.height - edgeScroll.edgeSize) {
                gameState.camera.y = Math.min(CONFIG.MAP_HEIGHT * CONFIG.TILE_SIZE - canvas.height, gameState.camera.y + speed);
            }
        }

        // Track mouse position globally
        document.addEventListener('mousemove', (e) => {
            edgeScroll.currentMouseX = e.clientX;
            edgeScroll.currentMouseY = e.clientY;
        });

        // ============================================
        // MENU FUNCTIONS
        // ============================================
        function showGameSetup() {
            document.getElementById('game-setup').classList.add('active');
            updateOpponentList();
            updateMapPreview();
        }

        function hideGameSetup() {
            document.getElementById('game-setup').classList.remove('active');
        }

        function showOptions() {
            // For now, just show a message - can be expanded later
            alert('Options coming soon! Press \` to open the cheat console during gameplay.');
        }

        function showOptionsInGame() {
            // For now, just show a message
            alert('Options coming soon! Press \` to open the cheat console.');
        }

        function showLoadMenu() {
            document.getElementById('save-load-title').textContent = 'üìÇ Load Game';
            renderSaveSlots('load');
            document.getElementById('save-load-menu').classList.add('active');
        }

        function showSaveMenu() {
            document.getElementById('save-load-title').textContent = 'üíæ Save Game';
            renderSaveSlots('save');
            document.getElementById('save-load-menu').classList.add('active');
        }

        function showLoadMenuInGame() {
            document.getElementById('save-load-title').textContent = 'üìÇ Load Game';
            renderSaveSlots('load');
            document.getElementById('save-load-menu').classList.add('active');
        }

        function hideSaveLoadMenu() {
            document.getElementById('save-load-menu').classList.remove('active');
        }

        function updateOpponentList() {
            const numOpponents = parseInt(document.getElementById('num-opponents').value);
            const container = document.getElementById('opponent-list');
            container.innerHTML = '';

            GAME_SETTINGS.opponents = [];

            for (let i = 0; i < numOpponents; i++) {
                const opponent = {
                    name: OPPONENT_NAMES[i],
                    difficulty: 'medium',
                    color: OPPONENT_COLORS[i]
                };
                GAME_SETTINGS.opponents.push(opponent);

                const div = document.createElement('div');
                div.className = 'opponent-config';
                div.innerHTML = `
                    <div class="opponent-header">
                        <span class="opponent-name">
                            <span class="opponent-color" style="background: ${opponent.color}"></span>
                            ${opponent.name}
                        </span>
                    </div>
                    <div class="setup-row">
                        <span class="setup-label">Difficulty:</span>
                        <select class="setup-select" onchange="updateOpponentDifficulty(${i}, this.value)">
                            <option value="easy">Easy</option>
                            <option value="medium" selected>Medium</option>
                            <option value="hard">Hard</option>
                        </select>
                    </div>
                `;
                container.appendChild(div);
            }
        }

        function updateOpponentDifficulty(index, difficulty) {
            if (GAME_SETTINGS.opponents[index]) {
                GAME_SETTINGS.opponents[index].difficulty = difficulty;
            }
        }

        function updateMapPreview() {
            const mapSize = document.getElementById('map-size').value;
            const mapType = document.getElementById('map-type').value;
            const preview = document.getElementById('map-preview');

            const size = MAP_SIZES[mapSize];
            const typeDescriptions = {
                continental: 'Large landmass with water borders',
                islands: 'Multiple islands separated by water',
                desert: 'Arid landscape with oases',
                forest: 'Dense woodland with clearings',
                highlands: 'Mountainous terrain with valleys',
                archipelago: 'Many small islands'
            };

            preview.innerHTML = `
                <div style="text-align: center;">
                    <div style="font-size: 24px; margin-bottom: 8px;">
                        ${mapType === 'continental' ? 'üåç' : mapType === 'islands' ? 'üèùÔ∏è' : mapType === 'desert' ? 'üèúÔ∏è' : mapType === 'forest' ? 'üå≤' : mapType === 'highlands' ? '‚õ∞Ô∏è' : 'üèùÔ∏è'}
                    </div>
                    <div style="font-weight: bold; margin-bottom: 4px;">${mapType.charAt(0).toUpperCase() + mapType.slice(1)}</div>
                    <div style="font-size: 11px;">${size.width} √ó ${size.height} tiles</div>
                    <div style="font-size: 10px; margin-top: 4px;">${typeDescriptions[mapType]}</div>
                </div>
            `;
        }

        function pauseGame() {
            GAME_SETTINGS.gamePaused = true;
            document.getElementById('pause-menu').classList.add('active');
        }

        function resumeGame() {
            GAME_SETTINGS.gamePaused = false;
            document.getElementById('pause-menu').classList.remove('active');
        }

        function returnToMainMenu() {
            if (confirm('Return to main menu? Unsaved progress will be lost.')) {
                location.reload();
            }
        }

        // ============================================
        // SAVE/LOAD SYSTEM
        // ============================================
        const SAVE_SLOTS = 5;

        function renderSaveSlots(mode) {
            const container = document.getElementById('save-slots');
            container.innerHTML = '';

            for (let i = 1; i <= SAVE_SLOTS; i++) {
                const saveData = localStorage.getItem(`rts_save_${i}`);
                const slot = document.createElement('div');
                slot.className = 'save-slot' + (saveData ? '' : ' empty');

                if (saveData) {
                    const data = JSON.parse(saveData);
                    slot.innerHTML = `
                        <div class="save-slot-header">
                            <span class="save-slot-name">Slot ${i}: ${data.playerName || 'Unknown'}</span>
                            <span class="save-slot-date">${data.saveDate || 'Unknown date'}</span>
                        </div>
                        <div class="save-slot-info">
                            Age: ${['Stone', 'Bronze', 'Iron', 'Imperial'][data.currentAge || 0]} |
                            Units: ${data.unitCount || 0} |
                            Opponents: ${data.opponentCount || 1}
                        </div>
                    `;
                    slot.onclick = () => mode === 'save' ? saveGame(i) : loadGame(i);
                } else {
                    slot.innerHTML = mode === 'save' ? `Click to save to Slot ${i}` : `Slot ${i} - Empty`;
                    if (mode === 'save') {
                        slot.onclick = () => saveGame(i);
                    }
                }
                container.appendChild(slot);
            }
        }

        function saveGame(slotNum) {
            if (!GAME_SETTINGS.gameStarted) return;

            const saveData = {
                saveDate: new Date().toLocaleString(),
                playerName: GAME_SETTINGS.playerName,
                currentAge: gameState.currentAge,
                unitCount: gameState.units.length,
                opponentCount: GAME_SETTINGS.opponents.length,
                config: { ...CONFIG },
                gameSettings: { ...GAME_SETTINGS },
                gameState: {
                    resources: { ...gameState.resources },
                    population: gameState.population,
                    maxPopulation: gameState.maxPopulation,
                    currentAge: gameState.currentAge,
                    gameTime: gameState.gameTime,
                    upgrades: { ...gameState.upgrades },
                    researchedTechs: [...(gameState.researchedTechs || [])],
                    techBonuses: { ...(gameState.techBonuses || {}) }
                },
                units: gameState.units.map(u => ({
                    type: u.type, x: u.x, y: u.y, hp: u.hp, maxHp: u.maxHp,
                    owner: u.owner, stance: u.stance
                })),
                buildings: gameState.buildings.map(b => ({
                    type: b.type, x: b.x, y: b.y, hp: b.hp, maxHp: b.maxHp,
                    owner: b.owner, isComplete: b.isComplete
                })),
                aiPlayers: aiPlayers.map(ai => ({
                    id: ai.id, name: ai.name, color: ai.color, difficulty: ai.difficulty,
                    resources: { ...ai.resources }, state: ai.state,
                    unitCount: ai.units.length, buildingCount: ai.buildings.length
                })),
                diplomacy: { ...diplomacy.relations }
            };

            localStorage.setItem(`rts_save_${slotNum}`, JSON.stringify(saveData));
            hideSaveLoadMenu();
            showMessage('Game saved!', 'success');
            updateContinueButton();
        }

        function loadGame(slotNum) {
            const saveData = localStorage.getItem(`rts_save_${slotNum}`);
            if (!saveData) return;

            const data = JSON.parse(saveData);

            // Restore configuration
            CONFIG = { ...data.config };
            Object.assign(GAME_SETTINGS, data.gameSettings);

            // Hide menus and start game
            document.getElementById('main-menu').classList.add('hidden');
            document.getElementById('game-setup').classList.remove('active');
            hideSaveLoadMenu();
            document.getElementById('pause-menu').classList.remove('active');
            document.getElementById('game-container').classList.remove('hidden');

            // Reinitialize game with saved state
            initializeGameFromSave(data);
        }

        function updateContinueButton() {
            let hasSaves = false;
            for (let i = 1; i <= SAVE_SLOTS; i++) {
                if (localStorage.getItem(`rts_save_${i}`)) {
                    hasSaves = true;
                    break;
                }
            }
            document.getElementById('continue-btn').disabled = !hasSaves;
        }

        // ============================================
        // MULTIPLE AI PLAYERS
        // ============================================
        let aiPlayers = [];

        function createAIPlayer(index, difficulty, color, name) {
            const difficultySettings = {
                easy: { resourceMult: 0.8, actionInterval: 4000, aggressiveness: 0.3 },
                medium: { resourceMult: 1.0, actionInterval: 2500, aggressiveness: 0.5 },
                hard: { resourceMult: 1.5, actionInterval: 1500, aggressiveness: 0.8 }
            };

            const settings = difficultySettings[difficulty];

            return {
                id: index,
                name: name,
                color: color,
                difficulty: difficulty,
                settings: settings,
                resources: {
                    food: 500 * settings.resourceMult,
                    wood: 500 * settings.resourceMult,
                    stone: 300 * settings.resourceMult,
                    gold: 200 * settings.resourceMult,
                    gems: 0
                },
                buildings: [],
                units: [],
                state: 'building',
                lastActionTime: 0,
                baseX: 0,
                baseY: 0
            };
        }

        function initializeAIPlayers() {
            aiPlayers = [];

            const numOpponents = GAME_SETTINGS.opponents.length;
            const corners = [
                { x: CONFIG.MAP_WIDTH - 10, y: CONFIG.MAP_HEIGHT - 10 }, // Bottom right
                { x: CONFIG.MAP_WIDTH - 10, y: 5 },                      // Top right
                { x: 5, y: CONFIG.MAP_HEIGHT - 10 },                     // Bottom left
                { x: Math.floor(CONFIG.MAP_WIDTH / 2), y: CONFIG.MAP_HEIGHT - 10 }, // Bottom center
                { x: Math.floor(CONFIG.MAP_WIDTH / 2), y: 5 },           // Top center
                { x: CONFIG.MAP_WIDTH - 10, y: Math.floor(CONFIG.MAP_HEIGHT / 2) }, // Right center
                { x: 5, y: Math.floor(CONFIG.MAP_HEIGHT / 2) }           // Left center
            ];

            for (let i = 0; i < numOpponents; i++) {
                const opponent = GAME_SETTINGS.opponents[i];
                const ai = createAIPlayer(i, opponent.difficulty, opponent.color, opponent.name);
                ai.baseX = corners[i].x;
                ai.baseY = corners[i].y;
                aiPlayers.push(ai);
            }
        }

        function updateAllAIPlayers(deltaTime) {
            for (const ai of aiPlayers) {
                updateAIPlayer(ai, deltaTime);
            }
        }

        function updateAIPlayer(ai, deltaTime) {
            const now = Date.now();
            if (now - ai.lastActionTime < ai.settings.actionInterval) return;
            ai.lastActionTime = now;

            // Resource generation for AI buildings
            for (const building of ai.buildings) {
                if (building.isComplete) {
                    const def = BUILDINGS[building.type];
                    if (def.resourceGen) {
                        for (const [resource, amount] of Object.entries(def.resourceGen)) {
                            ai.resources[resource] += amount * ai.settings.resourceMult * (deltaTime / 1000);
                        }
                    }
                }
            }

            // Consider peace if at war and losing
            if (diplomacy.isAtWar(ai.id)) {
                aiConsiderPeace(ai);
            }

            // State machine
            switch (ai.state) {
                case 'building':
                    aiTryBuild(ai);
                    if (ai.units.length >= 5 + Math.floor(ai.buildings.length / 2)) {
                        ai.state = Math.random() < ai.settings.aggressiveness ? 'attacking' : 'expanding';
                    }
                    break;
                case 'expanding':
                    aiTryBuild(ai);
                    aiTrainUnits(ai);
                    if (ai.units.length >= 10) {
                        ai.state = 'attacking';
                    }
                    break;
                case 'attacking':
                    aiCommandAttack(ai);
                    if (ai.units.length < 3) {
                        ai.state = 'building';
                    }
                    break;
                case 'defending':
                    aiDefendBase(ai);
                    if (ai.units.length >= 5) {
                        ai.state = 'building';
                    }
                    break;
            }

            // Train units periodically
            if (Math.random() < 0.3) {
                aiTrainUnits(ai);
            }
        }

        function aiTryBuild(ai) {
            const buildPriority = ['barracks', 'farm', 'house', 'lumberMill', 'quarry'];
            for (const buildingType of buildPriority) {
                const def = BUILDINGS[buildingType];
                if (aiCanAfford(ai, def.cost)) {
                    const pos = aiFindBuildPosition(ai, def.width, def.height);
                    if (pos) {
                        aiSpendResources(ai, def.cost);
                        const building = {
                            type: buildingType,
                            x: pos.x,
                            y: pos.y,
                            owner: ai.id,
                            hp: def.hp,
                            maxHp: def.hp,
                            isComplete: true,
                            trainingQueue: []
                        };
                        ai.buildings.push(building);

                        // Mark tiles
                        for (let dy = 0; dy < def.height; dy++) {
                            for (let dx = 0; dx < def.width; dx++) {
                                if (gameState.map[pos.y + dy] && gameState.map[pos.y + dy][pos.x + dx]) {
                                    gameState.map[pos.y + dy][pos.x + dx].building = building;
                                }
                            }
                        }
                        break;
                    }
                }
            }
        }

        function aiTrainUnits(ai) {
            const barracks = ai.buildings.find(b => b.type === 'barracks' && b.isComplete);
            if (!barracks) return;

            const unitType = Math.random() < 0.6 ? 'swordsman' : 'archer';
            const def = UNITS[unitType];

            if (aiCanAfford(ai, def.cost) && ai.units.length < 20) {
                aiSpendResources(ai, def.cost);
                const unit = {
                    id: Date.now() + Math.random(),
                    type: unitType,
                    x: barracks.x + 1,
                    y: barracks.y + 2,
                    owner: ai.id,
                    hp: def.hp,
                    maxHp: def.hp,
                    targetX: null,
                    targetY: null,
                    attacking: null,
                    stance: 'aggressive'
                };
                ai.units.push(unit);
            }
        }

        function aiCommandAttack(ai) {
            // Only attack if at war
            if (!diplomacy.isAtWar(ai.id)) {
                // Consider declaring war based on aggressiveness
                aiConsiderDeclareWar(ai);
                return;
            }

            // Find player units/buildings to attack
            const targets = [...gameState.units, ...gameState.buildings];
            if (targets.length === 0) return;

            const target = targets[Math.floor(Math.random() * targets.length)];

            for (const unit of ai.units) {
                if (!unit.attacking && Math.random() < ai.settings.aggressiveness) {
                    unit.targetX = target.x;
                    unit.targetY = target.y;
                    unit.attacking = target;
                }
            }
        }

        function aiConsiderDeclareWar(ai) {
            // AI considers declaring war based on aggressiveness and game state
            const rel = diplomacy.relations[ai.id];
            if (!rel || rel.state === DIPLOMATIC_STATES.WAR) return;

            // Don't break alliances easily
            if (rel.state === DIPLOMATIC_STATES.ALLIED) {
                // Very rare for AI to break alliance
                if (Math.random() > 0.001 * ai.settings.aggressiveness) return;
            }

            // Calculate war likelihood
            let warChance = 0.001 * ai.settings.aggressiveness;

            // More likely if AI has many units
            if (ai.units.length >= 8) warChance += 0.002;
            if (ai.units.length >= 15) warChance += 0.003;

            // More likely over time at peace
            warChance += Math.min(rel.turnsAtPeace / 100000, 0.005);

            // Hard AI more aggressive
            if (ai.difficulty === 'hard') warChance *= 2;
            if (ai.difficulty === 'easy') warChance *= 0.3;

            if (Math.random() < warChance) {
                diplomacy.aiDeclareWar(ai.id);
            }
        }

        function aiConsiderPeace(ai) {
            // AI considers offering peace if losing
            const rel = diplomacy.relations[ai.id];
            if (!rel || rel.state !== DIPLOMATIC_STATES.WAR) return;

            // Only consider peace if AI is struggling
            if (ai.units.length > 3 && ai.buildings.length > 2) return;

            let peaceChance = 0.01;
            if (ai.units.length < 2) peaceChance += 0.05;
            if (ai.buildings.length < 2) peaceChance += 0.05;

            // Easier AI more likely to offer peace
            if (ai.difficulty === 'easy') peaceChance *= 2;
            if (ai.difficulty === 'hard') peaceChance *= 0.5;

            if (Math.random() < peaceChance) {
                // Offer tribute based on AI resources
                const tribute = Math.floor(ai.resources.gold * 0.3);
                diplomacy.aiOfferPeace(ai.id, tribute);
            }
        }

        function aiDefendBase(ai) {
            for (const unit of ai.units) {
                if (!unit.attacking) {
                    unit.targetX = ai.baseX + Math.floor(Math.random() * 6) - 3;
                    unit.targetY = ai.baseY + Math.floor(Math.random() * 6) - 3;
                }
            }
        }

        function aiCanAfford(ai, cost) {
            for (const [resource, amount] of Object.entries(cost)) {
                if ((ai.resources[resource] || 0) < amount) return false;
            }
            return true;
        }

        function aiSpendResources(ai, cost) {
            for (const [resource, amount] of Object.entries(cost)) {
                ai.resources[resource] -= amount;
            }
        }

        function aiFindBuildPosition(ai, width, height) {
            for (let attempts = 0; attempts < 20; attempts++) {
                const x = ai.baseX + Math.floor(Math.random() * 15) - 7;
                const y = ai.baseY + Math.floor(Math.random() * 15) - 7;

                if (x >= 0 && y >= 0 && x + width < CONFIG.MAP_WIDTH && y + height < CONFIG.MAP_HEIGHT) {
                    let canPlace = true;
                    for (let dy = 0; dy < height && canPlace; dy++) {
                        for (let dx = 0; dx < width && canPlace; dx++) {
                            const tile = gameState.map[y + dy]?.[x + dx];
                            if (!tile || tile.terrain === 'WATER' || tile.terrain === 'MOUNTAIN' || tile.building) {
                                canPlace = false;
                            }
                        }
                    }
                    if (canPlace) return { x, y };
                }
            }
            return null;
        }

        // Building definitions
        const BUILDINGS = {
            townCenter: {
                name: 'Town Center',
                icon: 'üèõÔ∏è',
                width: 3,
                height: 3,
                cost: { wood: 400, stone: 200 },
                hp: 2000,
                produces: ['villager'],
                populationProvided: 5,
                description: 'Main building. Produces villagers and provides population.'
            },
            house: {
                name: 'House',
                icon: 'üè†',
                width: 2,
                height: 2,
                cost: { wood: 50 },
                hp: 300,
                populationProvided: 10,
                description: 'Provides housing for your population.'
            },
            farm: {
                name: 'Farm',
                icon: 'üåæ',
                width: 2,
                height: 2,
                cost: { wood: 60 },
                hp: 200,
                resourceGen: { food: 5 },
                description: 'Generates food over time.'
            },
            lumberMill: {
                name: 'Lumber Mill',
                icon: 'ü™ì',
                width: 2,
                height: 2,
                cost: { wood: 100 },
                hp: 400,
                resourceGen: { wood: 4 },
                description: 'Generates wood over time.'
            },
            quarry: {
                name: 'Quarry',
                icon: '‚õèÔ∏è',
                width: 2,
                height: 2,
                cost: { wood: 100, stone: 50 },
                hp: 500,
                resourceGen: { stone: 3 },
                description: 'Generates stone over time.'
            },
            mine: {
                name: 'Gold Mine',
                icon: '‚öíÔ∏è',
                width: 2,
                height: 2,
                cost: { wood: 150, stone: 100 },
                hp: 500,
                resourceGen: { gold: 2 },
                description: 'Generates gold over time.'
            },
            gemMine: {
                name: 'Gem Mine',
                icon: 'üíé',
                width: 2,
                height: 2,
                cost: { wood: 200, stone: 150, gold: 50 },
                hp: 600,
                resourceGen: { gems: 1 },
                description: 'Generates precious gems over time.'
            },
            barracks: {
                name: 'Barracks',
                icon: 'üè∞',
                width: 3,
                height: 2,
                cost: { wood: 150, stone: 100 },
                hp: 800,
                produces: ['swordsman', 'spearman'],
                description: 'Trains infantry units.'
            },
            archeryRange: {
                name: 'Archery Range',
                icon: 'üèπ',
                width: 3,
                height: 2,
                cost: { wood: 175, stone: 75 },
                hp: 600,
                produces: ['archer', 'crossbowman'],
                description: 'Trains ranged units.'
            },
            stable: {
                name: 'Stable',
                icon: 'üê¥',
                width: 3,
                height: 3,
                cost: { wood: 200, stone: 100 },
                hp: 700,
                produces: ['cavalry', 'knight'],
                description: 'Trains mounted units.'
            },
            siegeWorkshop: {
                name: 'Siege Workshop',
                icon: 'üîß',
                width: 3,
                height: 3,
                cost: { wood: 300, stone: 200, gold: 100 },
                hp: 1000,
                produces: ['catapult', 'trebuchet'],
                description: 'Builds siege weapons.'
            },
            wall: {
                name: 'Wall',
                icon: 'üß±',
                width: 1,
                height: 1,
                cost: { stone: 20 },
                hp: 500,
                isWall: true,
                description: 'Defensive wall segment.'
            },
            tower: {
                name: 'Tower',
                icon: 'üóº',
                width: 2,
                height: 2,
                cost: { stone: 100, gold: 50 },
                hp: 800,
                attack: 15,
                range: 6,
                description: 'Defensive tower that attacks enemies.'
            }
        };

        // Unit definitions
        const UNITS = {
            villager: {
                name: 'Villager',
                icon: 'üë∑',
                cost: { food: 50 },
                hp: 40,
                attack: 3,
                defense: 0,
                speed: 2,
                range: 1,
                trainTime: 3000,
                population: 1,
                canBuild: true,
                description: 'Basic worker. Can build and gather.'
            },
            swordsman: {
                name: 'Swordsman',
                icon: '‚öîÔ∏è',
                cost: { food: 60, gold: 20 },
                hp: 80,
                attack: 12,
                defense: 4,
                speed: 2,
                range: 1,
                trainTime: 5000,
                population: 1,
                description: 'Basic melee infantry.'
            },
            spearman: {
                name: 'Spearman',
                icon: 'üó°Ô∏è',
                cost: { food: 50, wood: 25 },
                hp: 60,
                attack: 8,
                defense: 6,
                speed: 2,
                range: 1,
                trainTime: 4000,
                population: 1,
                bonusVs: 'cavalry',
                description: 'Anti-cavalry infantry.'
            },
            archer: {
                name: 'Archer',
                icon: 'üèπ',
                cost: { food: 40, wood: 40, gold: 10 },
                hp: 40,
                attack: 8,
                defense: 1,
                speed: 2.2,
                range: 5,
                trainTime: 4500,
                population: 1,
                description: 'Basic ranged unit.'
            },
            crossbowman: {
                name: 'Crossbowman',
                icon: 'üéØ',
                cost: { food: 50, wood: 30, gold: 30 },
                hp: 50,
                attack: 14,
                defense: 2,
                speed: 1.8,
                range: 6,
                trainTime: 6000,
                population: 1,
                description: 'Powerful ranged unit.'
            },
            cavalry: {
                name: 'Cavalry',
                icon: 'üêé',
                cost: { food: 80, gold: 60 },
                hp: 100,
                attack: 14,
                defense: 3,
                speed: 4,
                range: 1,
                trainTime: 7000,
                population: 2,
                description: 'Fast mounted unit.'
            },
            knight: {
                name: 'Knight',
                icon: 'üõ°Ô∏è',
                cost: { food: 100, gold: 100 },
                hp: 150,
                attack: 18,
                defense: 8,
                speed: 3.5,
                range: 1,
                trainTime: 10000,
                population: 2,
                description: 'Heavy cavalry.'
            },
            catapult: {
                name: 'Catapult',
                icon: 'ü™®',
                cost: { wood: 150, gold: 100 },
                hp: 80,
                attack: 40,
                defense: 0,
                speed: 1,
                range: 8,
                trainTime: 12000,
                population: 3,
                splashDamage: true,
                bonusVs: 'building',
                description: 'Siege weapon. Strong vs buildings.'
            },
            trebuchet: {
                name: 'Trebuchet',
                icon: '‚öôÔ∏è',
                cost: { wood: 200, gold: 200 },
                hp: 100,
                attack: 60,
                defense: 0,
                speed: 0.8,
                range: 12,
                trainTime: 18000,
                population: 4,
                splashDamage: true,
                bonusVs: 'building',
                description: 'Heavy siege. Devastating vs buildings.'
            },
            beast: {
                name: 'Beast',
                icon: 'üêâ',
                cost: { food: 500, gold: 500, gems: 50 },
                hp: 800,
                attack: 100,
                defense: 30,
                speed: 3,
                range: 2,
                trainTime: 30000,
                population: 8,
                splashDamage: true,
                description: 'Legendary beast. The mightiest unit in existence.'
            }
        };

        // ============================================
        // GAME STATE
        // ============================================
        const gameState = {
            resources: {
                food: 200,
                wood: 200,
                stone: 100,
                gold: 100,
                gems: 0
            },
            population: 0,
            maxPopulation: 10,
            buildings: [],
            units: [],
            selectedBuilding: null,
            selectedUnits: [],
            placingBuilding: null,
            camera: { x: 0, y: 0 },
            map: [],
            resourceRates: { food: 0, wood: 0, stone: 0, gold: 0, gems: 0 },
            enemyBuildings: [],
            enemyUnits: [],
            gameTime: 0,
            // Upgrade system
            upgrades: {
                attackLevel: 0,
                defenseLevel: 0,
                hpLevel: 0,
                speedLevel: 0
            },
            // Age/Tech progression
            currentAge: 0, // 0: Stone Age, 1: Bronze Age, 2: Iron Age, 3: Imperial Age
            ages: ['Stone Age', 'Bronze Age', 'Iron Age', 'Imperial Age'],
            // New systems
            researchedTechs: [],
            techBonuses: { attack: 0, defense: 0, speed: 0, hp: 0 },
            aiEnabled: true,
            godMode: false,
            gameSpeed: 1
        };

        // Upgrade definitions
        const UPGRADES = {
            attack: {
                name: 'Attack Upgrade',
                icon: '‚öîÔ∏è',
                maxLevel: 5,
                bonusPerLevel: 3,
                costs: [
                    { food: 100, gold: 50 },
                    { food: 200, gold: 100 },
                    { food: 350, gold: 200 },
                    { food: 500, gold: 350 },
                    { food: 750, gold: 500 }
                ],
                description: 'Increases attack damage of all units by +3 per level'
            },
            defense: {
                name: 'Defense Upgrade',
                icon: 'üõ°Ô∏è',
                maxLevel: 5,
                bonusPerLevel: 2,
                costs: [
                    { food: 100, stone: 75 },
                    { food: 200, stone: 150 },
                    { food: 350, stone: 250 },
                    { food: 500, stone: 400 },
                    { food: 750, stone: 600 }
                ],
                description: 'Increases defense of all units by +2 per level'
            },
            hp: {
                name: 'Vitality Upgrade',
                icon: '‚ù§Ô∏è',
                maxLevel: 5,
                bonusPerLevel: 15,
                costs: [
                    { food: 150, wood: 100 },
                    { food: 300, wood: 200 },
                    { food: 500, wood: 350 },
                    { food: 700, wood: 500 },
                    { food: 1000, wood: 750 }
                ],
                description: 'Increases max HP of all units by +15 per level'
            },
            speed: {
                name: 'Speed Upgrade',
                icon: 'üí®',
                maxLevel: 3,
                bonusPerLevel: 0.3,
                costs: [
                    { gold: 150, gems: 5 },
                    { gold: 300, gems: 15 },
                    { gold: 500, gems: 30 }
                ],
                description: 'Increases movement speed of all units by +0.3 per level'
            }
        };

        // Age advancement costs
        const AGE_COSTS = [
            { food: 500, wood: 300, stone: 200 },       // To Bronze Age
            { food: 1000, wood: 600, stone: 400, gold: 200 }, // To Iron Age
            { food: 2000, wood: 1200, stone: 800, gold: 500, gems: 50 } // To Imperial Age
        ];

        // ============================================
        // TECH TREE DEFINITIONS
        // ============================================
        const TECH_TREE = {
            // Stone Age techs
            stoneTools: {
                name: 'Stone Tools',
                age: 0,
                cost: { food: 100, wood: 50 },
                effect: { resourceBonus: 0.1 },
                description: '+10% resource gathering',
                requires: []
            },
            hunting: {
                name: 'Hunting',
                age: 0,
                cost: { food: 75 },
                effect: { foodBonus: 0.15 },
                description: '+15% food production',
                requires: []
            },
            // Bronze Age techs
            bronzeWorking: {
                name: 'Bronze Working',
                age: 1,
                cost: { food: 200, gold: 100 },
                effect: { attackBonus: 2 },
                description: '+2 attack for all units',
                requires: ['stoneTools']
            },
            wheelwright: {
                name: 'Wheelwright',
                age: 1,
                cost: { wood: 200, gold: 75 },
                effect: { speedBonus: 0.2 },
                description: '+0.2 speed for all units',
                requires: []
            },
            masonry: {
                name: 'Masonry',
                age: 1,
                cost: { stone: 200, wood: 100 },
                effect: { buildingHpBonus: 200 },
                description: '+200 HP for buildings',
                requires: []
            },
            // Iron Age techs
            ironWorking: {
                name: 'Iron Working',
                age: 2,
                cost: { food: 400, gold: 300 },
                effect: { attackBonus: 4 },
                description: '+4 attack for all units',
                requires: ['bronzeWorking']
            },
            chainMail: {
                name: 'Chain Mail',
                age: 2,
                cost: { gold: 350, stone: 200 },
                effect: { defenseBonus: 3 },
                description: '+3 defense for all units',
                requires: ['bronzeWorking']
            },
            siegecraft: {
                name: 'Siegecraft',
                age: 2,
                cost: { wood: 400, gold: 200 },
                effect: { siegeBonus: 20 },
                description: '+20 damage vs buildings',
                requires: ['masonry']
            },
            // Imperial Age techs
            steelWorking: {
                name: 'Steel Working',
                age: 3,
                cost: { food: 800, gold: 600 },
                effect: { attackBonus: 6, defenseBonus: 2 },
                description: '+6 attack, +2 defense',
                requires: ['ironWorking']
            },
            plateMail: {
                name: 'Plate Mail',
                age: 3,
                cost: { gold: 700, stone: 400 },
                effect: { defenseBonus: 5, hpBonus: 20 },
                description: '+5 defense, +20 HP',
                requires: ['chainMail']
            },
            engineering: {
                name: 'Engineering',
                age: 3,
                cost: { wood: 600, stone: 600, gold: 300 },
                effect: { rangeBonus: 2 },
                description: '+2 range for ranged units',
                requires: ['siegecraft']
            }
        };

        // ============================================
        // FOG OF WAR STATE
        // ============================================
        const fogState = {
            enabled: true,
            explored: [], // 2D array of explored tiles
            visible: [],  // 2D array of currently visible tiles
            visionRange: 5
        };

        // ============================================
        // SOUND SYSTEM
        // ============================================
        const soundSystem = {
            enabled: true,
            volume: 0.5,
            musicPlaying: false,
            sounds: {},

            // Web Audio API context
            audioContext: null,

            init() {
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                } catch (e) {
                    console.log('Web Audio not supported');
                }
            },

            // Generate simple synth sounds
            playTone(frequency, duration, type = 'sine') {
                if (!this.enabled || !this.audioContext) return;

                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(this.audioContext.destination);

                oscillator.type = type;
                oscillator.frequency.value = frequency;
                gainNode.gain.value = this.volume * 0.3;
                gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + duration);

                oscillator.start();
                oscillator.stop(this.audioContext.currentTime + duration);
            },

            playClick() { this.playTone(800, 0.1, 'square'); },
            playBuild() { this.playTone(400, 0.3, 'triangle'); },
            playTrain() { this.playTone(600, 0.2, 'sine'); },
            playAttack() { this.playTone(200, 0.15, 'sawtooth'); },
            playDeath() { this.playTone(150, 0.4, 'sawtooth'); },
            playVictory() {
                this.playTone(523, 0.2); // C
                setTimeout(() => this.playTone(659, 0.2), 200); // E
                setTimeout(() => this.playTone(784, 0.4), 400); // G
            },
            playDefeat() {
                this.playTone(300, 0.3);
                setTimeout(() => this.playTone(250, 0.3), 300);
                setTimeout(() => this.playTone(200, 0.5), 600);
            }
        };

        // ============================================
        // A* PATHFINDING
        // ============================================
        class PathFinder {
            static heuristic(a, b) {
                return Math.abs(a.x - b.x) + Math.abs(a.y - b.y);
            }

            static getNeighbors(node, map) {
                const neighbors = [];
                const dirs = [
                    { x: 0, y: -1 }, { x: 1, y: 0 },
                    { x: 0, y: 1 }, { x: -1, y: 0 },
                    // Diagonals
                    { x: 1, y: -1 }, { x: 1, y: 1 },
                    { x: -1, y: 1 }, { x: -1, y: -1 }
                ];

                for (const dir of dirs) {
                    const nx = node.x + dir.x;
                    const ny = node.y + dir.y;

                    if (nx >= 0 && nx < CONFIG.MAP_WIDTH && ny >= 0 && ny < CONFIG.MAP_HEIGHT) {
                        const tile = map[ny][nx];
                        if (TERRAIN[tile.terrain].walkable && !tile.building) {
                            neighbors.push({ x: nx, y: ny });
                        }
                    }
                }
                return neighbors;
            }

            static findPath(startX, startY, endX, endY, map) {
                const start = { x: Math.floor(startX), y: Math.floor(startY) };
                const end = { x: Math.floor(endX), y: Math.floor(endY) };

                // Check if end is valid
                if (end.x < 0 || end.x >= CONFIG.MAP_WIDTH || end.y < 0 || end.y >= CONFIG.MAP_HEIGHT) {
                    return null;
                }

                const endTile = map[end.y][end.x];
                if (!TERRAIN[endTile.terrain].walkable || endTile.building) {
                    // Find nearest valid tile
                    const validEnd = this.findNearestWalkable(end.x, end.y, map);
                    if (!validEnd) return null;
                    end.x = validEnd.x;
                    end.y = validEnd.y;
                }

                const openSet = [start];
                const closedSet = new Set();
                const gScore = new Map();
                const fScore = new Map();
                const cameFrom = new Map();

                const key = (n) => `${n.x},${n.y}`;

                gScore.set(key(start), 0);
                fScore.set(key(start), this.heuristic(start, end));

                let iterations = 0;
                const maxIterations = 1000;

                while (openSet.length > 0 && iterations < maxIterations) {
                    iterations++;

                    // Find node with lowest fScore
                    openSet.sort((a, b) => (fScore.get(key(a)) || Infinity) - (fScore.get(key(b)) || Infinity));
                    const current = openSet.shift();

                    if (current.x === end.x && current.y === end.y) {
                        // Reconstruct path
                        const path = [current];
                        let curr = current;
                        while (cameFrom.has(key(curr))) {
                            curr = cameFrom.get(key(curr));
                            path.unshift(curr);
                        }
                        return path;
                    }

                    closedSet.add(key(current));

                    for (const neighbor of this.getNeighbors(current, map)) {
                        if (closedSet.has(key(neighbor))) continue;

                        const isDiagonal = neighbor.x !== current.x && neighbor.y !== current.y;
                        const tentativeG = (gScore.get(key(current)) || 0) + (isDiagonal ? 1.414 : 1);

                        const neighborKey = key(neighbor);
                        if (!gScore.has(neighborKey) || tentativeG < gScore.get(neighborKey)) {
                            cameFrom.set(neighborKey, current);
                            gScore.set(neighborKey, tentativeG);
                            fScore.set(neighborKey, tentativeG + this.heuristic(neighbor, end));

                            if (!openSet.find(n => n.x === neighbor.x && n.y === neighbor.y)) {
                                openSet.push(neighbor);
                            }
                        }
                    }
                }

                return null; // No path found
            }

            static findNearestWalkable(x, y, map) {
                for (let radius = 1; radius < 10; radius++) {
                    for (let dx = -radius; dx <= radius; dx++) {
                        for (let dy = -radius; dy <= radius; dy++) {
                            const nx = x + dx;
                            const ny = y + dy;
                            if (nx >= 0 && nx < CONFIG.MAP_WIDTH && ny >= 0 && ny < CONFIG.MAP_HEIGHT) {
                                const tile = map[ny][nx];
                                if (TERRAIN[tile.terrain].walkable && !tile.building) {
                                    return { x: nx, y: ny };
                                }
                            }
                        }
                    }
                }
                return null;
            }
        }

        // ============================================
        // SOPHISTICATED ENEMY AI
        // ============================================
        const enemyAI = {
            lastActionTime: 0,
            actionInterval: 2000, // ms between AI decisions
            resources: { food: 500, wood: 500, stone: 300, gold: 200, gems: 0 },
            state: 'building', // 'building', 'expanding', 'attacking', 'defending'
            targetBuilding: null,

            update(deltaTime) {
                this.lastActionTime += deltaTime;

                if (this.lastActionTime < this.actionInterval) return;
                this.lastActionTime = 0;

                // Passive resource generation for AI
                this.resources.food += 10;
                this.resources.wood += 8;
                this.resources.stone += 5;
                this.resources.gold += 3;

                // Determine state based on situation
                const playerStrength = gameState.units.reduce((sum, u) => sum + UNITS[u.type].attack, 0);
                const enemyStrength = gameState.enemyUnits.reduce((sum, u) => sum + UNITS[u.type].attack, 0);

                if (enemyStrength < playerStrength * 0.5) {
                    this.state = 'defending';
                } else if (gameState.enemyBuildings.length < 3) {
                    this.state = 'building';
                } else if (enemyStrength > playerStrength * 1.5) {
                    this.state = 'attacking';
                } else {
                    this.state = 'expanding';
                }

                switch (this.state) {
                    case 'building':
                        this.tryBuildStructure();
                        this.tryTrainUnits();
                        break;
                    case 'expanding':
                        this.tryBuildStructure();
                        this.tryTrainUnits();
                        break;
                    case 'attacking':
                        this.commandAttack();
                        this.tryTrainUnits();
                        break;
                    case 'defending':
                        this.tryTrainUnits();
                        this.defendBase();
                        break;
                }
            },

            tryBuildStructure() {
                // AI building priorities
                const barracks = gameState.enemyBuildings.filter(b => b.type === 'barracks').length;
                const farms = gameState.enemyBuildings.filter(b => b.type === 'farm').length;

                if (farms < 2 && this.resources.wood >= 60) {
                    this.buildNearBase('farm');
                } else if (barracks < 2 && this.resources.wood >= 150 && this.resources.stone >= 100) {
                    this.buildNearBase('barracks');
                }
            },

            buildNearBase(type) {
                const tc = gameState.enemyBuildings.find(b => b.type === 'townCenter');
                if (!tc) return;

                const def = BUILDINGS[type];

                // Find valid spot near town center
                for (let radius = 3; radius < 10; radius++) {
                    for (let angle = 0; angle < Math.PI * 2; angle += 0.5) {
                        const x = Math.floor(tc.x + Math.cos(angle) * radius);
                        const y = Math.floor(tc.y + Math.sin(angle) * radius);

                        if (canPlaceBuilding(type, x, y)) {
                            // Deduct resources and build
                            for (const [res, amt] of Object.entries(def.cost)) {
                                this.resources[res] -= amt;
                            }
                            const building = placeBuilding(type, x, y, 'enemy');
                            building.isComplete = true;
                            building.constructionProgress = 100;
                            return true;
                        }
                    }
                }
                return false;
            },

            tryTrainUnits() {
                const barracks = gameState.enemyBuildings.filter(b => b.type === 'barracks' && b.isComplete);

                for (const barrack of barracks) {
                    if (barrack.trainingQueue.length < 2) {
                        // Train based on what we can afford
                        if (this.resources.food >= 60 && this.resources.gold >= 20 && gameState.enemyUnits.length < 20) {
                            this.resources.food -= 60;
                            this.resources.gold -= 20;

                            // Find spawn location
                            const def = BUILDINGS[barrack.type];
                            let spawnX = barrack.x + def.width;
                            let spawnY = barrack.y + def.height;

                            createUnit('swordsman', spawnX, spawnY, 'enemy');
                        }
                    }
                }
            },

            commandAttack() {
                const idleUnits = gameState.enemyUnits.filter(u => !u.attacking && !u.targetX);

                if (idleUnits.length >= 5) {
                    // Group attack
                    const target = gameState.buildings[0] || gameState.units[0];
                    if (target) {
                        for (const unit of idleUnits) {
                            unit.attacking = target;
                        }
                    }
                }
            },

            defendBase() {
                const tc = gameState.enemyBuildings.find(b => b.type === 'townCenter');
                if (!tc) return;

                // Move units back to defend
                for (const unit of gameState.enemyUnits) {
                    if (!unit.attacking) {
                        const dist = Math.sqrt(Math.pow(unit.x - tc.x, 2) + Math.pow(unit.y - tc.y, 2));
                        if (dist > 8) {
                            unit.targetX = tc.x + Math.random() * 4 - 2;
                            unit.targetY = tc.y + Math.random() * 4 - 2;
                        }
                    }
                }
            }
        };

        // ============================================
        // MULTIPLAYER FOUNDATION
        // ============================================
        const multiplayer = {
            socket: null,
            isHost: false,
            playerId: null,
            roomId: null,
            connected: false,

            connect(serverUrl) {
                try {
                    this.socket = new WebSocket(serverUrl);

                    this.socket.onopen = () => {
                        this.connected = true;
                        document.getElementById('mp-status').style.display = 'block';
                        document.getElementById('mp-status').textContent = 'Connected';
                        document.getElementById('mp-status').classList.add('connected');
                        showMessage('Connected to multiplayer server!', 'success');
                    };

                    this.socket.onclose = () => {
                        this.connected = false;
                        document.getElementById('mp-status').textContent = 'Disconnected';
                        document.getElementById('mp-status').classList.remove('connected');
                    };

                    this.socket.onmessage = (event) => {
                        const data = JSON.parse(event.data);
                        this.handleMessage(data);
                    };

                    this.socket.onerror = (error) => {
                        showMessage('Multiplayer connection failed', 'error');
                    };
                } catch (e) {
                    showMessage('WebSocket not supported', 'error');
                }
            },

            disconnect() {
                if (this.socket) {
                    this.socket.close();
                    this.socket = null;
                }
            },

            send(type, data) {
                if (this.socket && this.connected) {
                    this.socket.send(JSON.stringify({ type, data, playerId: this.playerId }));
                }
            },

            handleMessage(msg) {
                switch (msg.type) {
                    case 'joined':
                        this.playerId = msg.playerId;
                        this.roomId = msg.roomId;
                        showMessage(`Joined room: ${msg.roomId}`, 'success');
                        break;
                    case 'unitMove':
                        // Handle opponent unit movement
                        break;
                    case 'buildingPlace':
                        // Handle opponent building placement
                        break;
                    case 'attack':
                        // Handle combat sync
                        break;
                    case 'sync':
                        // Full game state sync
                        break;
                }
            },

            syncGameState() {
                this.send('sync', {
                    units: gameState.units,
                    buildings: gameState.buildings,
                    resources: gameState.resources
                });
            }
        };

        // ============================================
        // SPRITE RENDERING SYSTEM
        // ============================================
        const spriteRenderer = {
            enabled: true, // Toggle for emoji vs sprite mode

            // Draw unit using canvas shapes instead of emoji
            drawUnit(ctx, unit, x, y, size) {
                const def = UNITS[unit.type];
                const isPlayer = unit.owner === 'player';
                const baseColor = isPlayer ? '#4169E1' : '#DC143C';
                const darkColor = isPlayer ? '#1a3a7a' : '#8B0000';

                ctx.save();

                switch (unit.type) {
                    case 'villager':
                        this.drawVillager(ctx, x, y, size, baseColor, darkColor);
                        break;
                    case 'swordsman':
                        this.drawSwordsman(ctx, x, y, size, baseColor, darkColor);
                        break;
                    case 'archer':
                        this.drawArcher(ctx, x, y, size, baseColor, darkColor);
                        break;
                    case 'cavalry':
                    case 'knight':
                        this.drawCavalry(ctx, x, y, size, baseColor, darkColor);
                        break;
                    case 'catapult':
                    case 'trebuchet':
                        this.drawSiege(ctx, x, y, size, baseColor, darkColor);
                        break;
                    case 'beast':
                        this.drawBeast(ctx, x, y, size, baseColor, darkColor);
                        break;
                    case 'spearman':
                        this.drawSpearman(ctx, x, y, size, baseColor, darkColor);
                        break;
                    case 'crossbowman':
                        this.drawCrossbowman(ctx, x, y, size, baseColor, darkColor);
                        break;
                    default:
                        this.drawGenericUnit(ctx, x, y, size, baseColor, darkColor);
                }

                ctx.restore();
            },

            drawVillager(ctx, x, y, size, color, dark) {
                const cx = x + size / 2;
                const cy = y + size / 2;
                const r = size * 0.35;

                // Body
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(cx, cy, r, 0, Math.PI * 2);
                ctx.fill();

                // Head
                ctx.fillStyle = '#FFDAB9';
                ctx.beginPath();
                ctx.arc(cx, cy - r * 0.3, r * 0.5, 0, Math.PI * 2);
                ctx.fill();

                // Tool (pickaxe)
                ctx.strokeStyle = '#8B4513';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(cx + r * 0.3, cy - r * 0.2);
                ctx.lineTo(cx + r * 0.8, cy - r * 0.7);
                ctx.stroke();
            },

            drawSwordsman(ctx, x, y, size, color, dark) {
                const cx = x + size / 2;
                const cy = y + size / 2;
                const r = size * 0.35;

                // Body
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(cx, cy, r, 0, Math.PI * 2);
                ctx.fill();

                // Shield
                ctx.fillStyle = dark;
                ctx.beginPath();
                ctx.ellipse(cx - r * 0.4, cy, r * 0.4, r * 0.6, 0, 0, Math.PI * 2);
                ctx.fill();

                // Sword
                ctx.strokeStyle = '#C0C0C0';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(cx + r * 0.3, cy + r * 0.3);
                ctx.lineTo(cx + r * 0.9, cy - r * 0.5);
                ctx.stroke();
            },

            drawArcher(ctx, x, y, size, color, dark) {
                const cx = x + size / 2;
                const cy = y + size / 2;
                const r = size * 0.35;

                // Body
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(cx, cy, r, 0, Math.PI * 2);
                ctx.fill();

                // Bow
                ctx.strokeStyle = '#8B4513';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(cx + r * 0.2, cy, r * 0.7, -Math.PI * 0.4, Math.PI * 0.4);
                ctx.stroke();

                // Arrow
                ctx.strokeStyle = '#C0C0C0';
                ctx.beginPath();
                ctx.moveTo(cx - r * 0.3, cy);
                ctx.lineTo(cx + r * 0.9, cy);
                ctx.stroke();
            },

            drawCavalry(ctx, x, y, size, color, dark) {
                const cx = x + size / 2;
                const cy = y + size / 2;
                const r = size * 0.4;

                // Horse body
                ctx.fillStyle = '#8B4513';
                ctx.beginPath();
                ctx.ellipse(cx, cy + r * 0.2, r * 0.9, r * 0.5, 0, 0, Math.PI * 2);
                ctx.fill();

                // Rider
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(cx, cy - r * 0.3, r * 0.4, 0, Math.PI * 2);
                ctx.fill();
            },

            drawSiege(ctx, x, y, size, color, dark) {
                const cx = x + size / 2;
                const cy = y + size / 2;
                const r = size * 0.4;

                // Wheels
                ctx.fillStyle = '#4a3728';
                ctx.beginPath();
                ctx.arc(cx - r * 0.5, cy + r * 0.4, r * 0.3, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(cx + r * 0.5, cy + r * 0.4, r * 0.3, 0, Math.PI * 2);
                ctx.fill();

                // Frame
                ctx.fillStyle = '#8B4513';
                ctx.fillRect(cx - r * 0.7, cy - r * 0.3, r * 1.4, r * 0.5);

                // Arm
                ctx.strokeStyle = '#4a3728';
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.moveTo(cx, cy - r * 0.2);
                ctx.lineTo(cx + r * 0.6, cy - r * 0.8);
                ctx.stroke();
            },

            drawBeast(ctx, x, y, size, color, dark) {
                const cx = x + size / 2;
                const cy = y + size / 2;
                const r = size * 0.45;

                // Dragon/beast body - larger than other units
                ctx.fillStyle = '#8B0080'; // Purple for beast
                ctx.beginPath();
                ctx.ellipse(cx, cy + r * 0.1, r * 1.1, r * 0.8, 0, 0, Math.PI * 2);
                ctx.fill();

                // Head
                ctx.fillStyle = '#6B0060';
                ctx.beginPath();
                ctx.arc(cx + r * 0.6, cy - r * 0.3, r * 0.5, 0, Math.PI * 2);
                ctx.fill();

                // Horns
                ctx.strokeStyle = '#FFD700';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(cx + r * 0.5, cy - r * 0.6);
                ctx.lineTo(cx + r * 0.3, cy - r * 1.0);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(cx + r * 0.8, cy - r * 0.5);
                ctx.lineTo(cx + r * 1.0, cy - r * 0.9);
                ctx.stroke();

                // Wings
                ctx.fillStyle = '#9B30FF';
                ctx.beginPath();
                ctx.moveTo(cx, cy);
                ctx.lineTo(cx - r * 0.8, cy - r * 0.9);
                ctx.lineTo(cx - r * 0.3, cy - r * 0.2);
                ctx.closePath();
                ctx.fill();

                // Eyes (glowing)
                ctx.fillStyle = '#FF4500';
                ctx.beginPath();
                ctx.arc(cx + r * 0.7, cy - r * 0.4, r * 0.12, 0, Math.PI * 2);
                ctx.fill();

                // Tail
                ctx.strokeStyle = '#8B0080';
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.moveTo(cx - r * 0.6, cy + r * 0.1);
                ctx.quadraticCurveTo(cx - r * 1.2, cy + r * 0.5, cx - r * 0.8, cy + r * 0.8);
                ctx.stroke();
            },

            drawSpearman(ctx, x, y, size, color, dark) {
                const cx = x + size / 2;
                const cy = y + size / 2;
                const r = size * 0.35;

                // Body
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(cx, cy, r, 0, Math.PI * 2);
                ctx.fill();

                // Spear
                ctx.strokeStyle = '#8B4513';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(cx - r * 0.2, cy + r * 0.5);
                ctx.lineTo(cx + r * 0.3, cy - r * 1.0);
                ctx.stroke();

                // Spear tip
                ctx.fillStyle = '#C0C0C0';
                ctx.beginPath();
                ctx.moveTo(cx + r * 0.3, cy - r * 1.0);
                ctx.lineTo(cx + r * 0.15, cy - r * 0.7);
                ctx.lineTo(cx + r * 0.45, cy - r * 0.7);
                ctx.closePath();
                ctx.fill();
            },

            drawCrossbowman(ctx, x, y, size, color, dark) {
                const cx = x + size / 2;
                const cy = y + size / 2;
                const r = size * 0.35;

                // Body
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(cx, cy, r, 0, Math.PI * 2);
                ctx.fill();

                // Crossbow frame
                ctx.strokeStyle = '#8B4513';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(cx - r * 0.6, cy);
                ctx.lineTo(cx + r * 0.8, cy);
                ctx.stroke();

                // Crossbow bow
                ctx.strokeStyle = '#4a3728';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(cx + r * 0.4, cy - r * 0.6);
                ctx.lineTo(cx + r * 0.6, cy);
                ctx.lineTo(cx + r * 0.4, cy + r * 0.6);
                ctx.stroke();

                // Bolt
                ctx.strokeStyle = '#C0C0C0';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(cx - r * 0.4, cy);
                ctx.lineTo(cx + r * 0.5, cy);
                ctx.stroke();
            },

            drawGenericUnit(ctx, x, y, size, color, dark) {
                const cx = x + size / 2;
                const cy = y + size / 2;
                const r = size * 0.35;

                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(cx, cy, r, 0, Math.PI * 2);
                ctx.fill();

                ctx.strokeStyle = dark;
                ctx.lineWidth = 2;
                ctx.stroke();
            },

            // Draw building using canvas shapes
            drawBuilding(ctx, building, x, y, width, height) {
                const def = BUILDINGS[building.type];
                const isPlayer = building.owner === 'player';
                const baseColor = isPlayer ? 'rgba(100, 149, 237, 0.9)' : 'rgba(220, 60, 60, 0.9)';
                const roofColor = isPlayer ? '#4169E1' : '#8B0000';

                ctx.save();

                // Building base
                ctx.fillStyle = baseColor;
                ctx.fillRect(x, y + height * 0.3, width, height * 0.7);

                // Roof
                ctx.fillStyle = roofColor;
                ctx.beginPath();
                ctx.moveTo(x, y + height * 0.3);
                ctx.lineTo(x + width / 2, y);
                ctx.lineTo(x + width, y + height * 0.3);
                ctx.closePath();
                ctx.fill();

                // Window/door details based on building type
                ctx.fillStyle = '#2a2a3a';
                if (building.type === 'townCenter') {
                    // Large door
                    ctx.fillRect(x + width * 0.35, y + height * 0.5, width * 0.3, height * 0.5);
                    // Windows
                    ctx.fillRect(x + width * 0.1, y + height * 0.4, width * 0.15, height * 0.15);
                    ctx.fillRect(x + width * 0.75, y + height * 0.4, width * 0.15, height * 0.15);
                } else if (building.type === 'barracks') {
                    // Multiple doors
                    ctx.fillRect(x + width * 0.1, y + height * 0.6, width * 0.2, height * 0.4);
                    ctx.fillRect(x + width * 0.7, y + height * 0.6, width * 0.2, height * 0.4);
                } else {
                    // Simple door
                    ctx.fillRect(x + width * 0.4, y + height * 0.6, width * 0.2, height * 0.4);
                }

                ctx.restore();
            }
        };

        // ============================================
        // CHEAT CONSOLE SYSTEM
        // ============================================
        let consoleHistory = [];
        let historyIndex = -1;
        let consoleOpen = false;

        const cheatCommands = {
            help: () => {
                return `Available commands:
  resources [amount] - Add resources (default: 10000)
  spawn [unit] [count] - Spawn units (swordsman, archer, cavalry, knight, beast, etc.)
  kill [all|enemies|player] - Kill units
  god - Toggle invincibility
  reveal - Reveal entire map (disable fog)
  age [0-3] - Set age (0=Stone, 1=Bronze, 2=Iron, 3=Imperial)
  upgrade [type] [level] - Set upgrade level (attack, defense, hp, speed)
  win - Instant victory
  lose - Instant defeat
  speed [multiplier] - Game speed (0.5, 1, 2, etc.)
  teleport [x] [y] - Move selected units
  heal - Heal all player units
  damage [amount] - Damage all enemies
  build [type] - Instantly place building at camera center
  clear - Clear console
  mp connect [url] - Connect to multiplayer server
  mp disconnect - Disconnect from server
  sound [on|off] - Toggle sound
  fog [on|off] - Toggle fog of war
  ai [on|off] - Toggle enemy AI
  stats - Show game statistics

Special Units:
  beast - The mightiest unit (800 HP, 100 ATK, 30 DEF)
  Example: spawn beast 3`;
            },

            resources: (args) => {
                const amount = parseInt(args[0]) || 10000;
                gameState.resources.food += amount;
                gameState.resources.wood += amount;
                gameState.resources.stone += amount;
                gameState.resources.gold += amount;
                gameState.resources.gems += Math.floor(amount / 10);
                return `Added ${amount} of each resource!`;
            },

            spawn: (args) => {
                const unitType = args[0] || 'swordsman';
                const count = parseInt(args[1]) || 1;

                if (!UNITS[unitType]) {
                    return `Unknown unit type: ${unitType}. Available: ${Object.keys(UNITS).join(', ')}`;
                }

                const tc = gameState.buildings.find(b => b.type === 'townCenter');
                const baseX = tc ? tc.x + 2 : 10;
                const baseY = tc ? tc.y + 4 : 12;

                for (let i = 0; i < count; i++) {
                    createUnit(unitType, baseX + (i % 5), baseY + Math.floor(i / 5), 'player');
                }
                return `Spawned ${count} ${unitType}(s)!`;
            },

            kill: (args) => {
                const target = args[0] || 'enemies';
                let killed = 0;

                if (target === 'all' || target === 'enemies') {
                    killed += gameState.enemyUnits.length;
                    gameState.enemyUnits.forEach(u => removeUnit(u));
                    gameState.enemyUnits = [];
                }
                if (target === 'all' || target === 'player') {
                    killed += gameState.units.length;
                    gameState.units.forEach(u => {
                        gameState.population -= UNITS[u.type].population;
                    });
                    gameState.units = [];
                }
                return `Killed ${killed} units!`;
            },

            god: () => {
                gameState.godMode = !gameState.godMode;
                if (gameState.godMode) {
                    for (const unit of gameState.units) {
                        unit.hp = 99999;
                        unit.maxHp = 99999;
                    }
                }
                return `God mode: ${gameState.godMode ? 'ON' : 'OFF'}`;
            },

            reveal: () => {
                fogState.enabled = false;
                for (let y = 0; y < CONFIG.MAP_HEIGHT; y++) {
                    for (let x = 0; x < CONFIG.MAP_WIDTH; x++) {
                        fogState.explored[y][x] = true;
                        fogState.visible[y][x] = true;
                    }
                }
                return 'Map revealed!';
            },

            age: (args) => {
                const age = parseInt(args[0]);
                if (isNaN(age) || age < 0 || age > 3) {
                    return 'Usage: age [0-3] (0=Stone, 1=Bronze, 2=Iron, 3=Imperial)';
                }
                gameState.currentAge = age;
                return `Age set to ${gameState.ages[age]}!`;
            },

            upgrade: (args) => {
                const type = args[0];
                const level = parseInt(args[1]);

                const types = ['attack', 'defense', 'hp', 'speed'];
                if (!types.includes(type)) {
                    return `Usage: upgrade [${types.join('|')}] [level]`;
                }

                const maxLevel = UPGRADES[type].maxLevel;
                if (isNaN(level) || level < 0 || level > maxLevel) {
                    return `Level must be 0-${maxLevel}`;
                }

                gameState.upgrades[type + 'Level'] = level;
                return `${type} upgraded to level ${level}!`;
            },

            win: () => {
                gameState.enemyBuildings = [];
                gameState.enemyUnits = [];
                return 'Victory triggered!';
            },

            lose: () => {
                gameState.buildings = [];
                return 'Defeat triggered!';
            },

            speed: (args) => {
                const multiplier = parseFloat(args[0]) || 1;
                gameState.gameSpeed = multiplier;
                return `Game speed set to ${multiplier}x`;
            },

            teleport: (args) => {
                const x = parseInt(args[0]);
                const y = parseInt(args[1]);

                if (isNaN(x) || isNaN(y)) {
                    return 'Usage: teleport [x] [y]';
                }

                for (const unit of gameState.selectedUnits) {
                    unit.x = x;
                    unit.y = y;
                    unit.targetX = null;
                    unit.targetY = null;
                }
                return `Teleported ${gameState.selectedUnits.length} units to (${x}, ${y})`;
            },

            heal: () => {
                for (const unit of gameState.units) {
                    unit.hp = unit.maxHp;
                }
                return `Healed ${gameState.units.length} units!`;
            },

            damage: (args) => {
                const amount = parseInt(args[0]) || 50;
                for (const unit of gameState.enemyUnits) {
                    unit.hp -= amount;
                    if (unit.hp <= 0) {
                        removeUnit(unit);
                    }
                }
                return `Dealt ${amount} damage to all enemies!`;
            },

            build: (args) => {
                const type = args[0];
                if (!BUILDINGS[type]) {
                    return `Unknown building: ${type}. Available: ${Object.keys(BUILDINGS).join(', ')}`;
                }

                const x = Math.floor(gameState.camera.x / CONFIG.TILE_SIZE) + 5;
                const y = Math.floor(gameState.camera.y / CONFIG.TILE_SIZE) + 5;

                if (canPlaceBuilding(type, x, y)) {
                    const building = placeBuilding(type, x, y, 'player');
                    building.isComplete = true;
                    building.constructionProgress = 100;
                    return `Built ${BUILDINGS[type].name} at (${x}, ${y})!`;
                }
                return 'Cannot place building at that location!';
            },

            clear: () => {
                document.getElementById('console-output').innerHTML = '';
                return '';
            },

            mp: (args) => {
                const action = args[0];
                if (action === 'connect') {
                    const url = args[1] || 'ws://localhost:8080';
                    multiplayer.connect(url);
                    return `Connecting to ${url}...`;
                } else if (action === 'disconnect') {
                    multiplayer.disconnect();
                    return 'Disconnected from server';
                }
                return 'Usage: mp connect [url] | mp disconnect';
            },

            sound: (args) => {
                const state = args[0];
                if (state === 'on') {
                    soundSystem.enabled = true;
                } else if (state === 'off') {
                    soundSystem.enabled = false;
                } else {
                    soundSystem.enabled = !soundSystem.enabled;
                }
                document.getElementById('sound-toggle').textContent = soundSystem.enabled ? 'üîä' : 'üîá';
                return `Sound: ${soundSystem.enabled ? 'ON' : 'OFF'}`;
            },

            fog: (args) => {
                const state = args[0];
                if (state === 'on') {
                    fogState.enabled = true;
                } else if (state === 'off') {
                    fogState.enabled = false;
                } else {
                    fogState.enabled = !fogState.enabled;
                }
                return `Fog of war: ${fogState.enabled ? 'ON' : 'OFF'}`;
            },

            ai: (args) => {
                const state = args[0];
                if (state === 'on') {
                    gameState.aiEnabled = true;
                } else if (state === 'off') {
                    gameState.aiEnabled = false;
                } else {
                    gameState.aiEnabled = !gameState.aiEnabled;
                }
                return `Enemy AI: ${gameState.aiEnabled ? 'ON' : 'OFF'}`;
            },

            stats: () => {
                return `Game Statistics:
  Time: ${Math.floor(gameState.gameTime / 1000)}s
  Player Units: ${gameState.units.length}
  Enemy Units: ${gameState.enemyUnits.length}
  Player Buildings: ${gameState.buildings.length}
  Enemy Buildings: ${gameState.enemyBuildings.length}
  Population: ${gameState.population}/${gameState.maxPopulation}
  Age: ${gameState.ages[gameState.currentAge]}
  Upgrades: ATK ${gameState.upgrades.attackLevel}, DEF ${gameState.upgrades.defenseLevel}, HP ${gameState.upgrades.hpLevel}, SPD ${gameState.upgrades.speedLevel}`;
            }
        };

        function toggleConsole() {
            consoleOpen = !consoleOpen;
            document.getElementById('cheat-console').classList.toggle('active', consoleOpen);
            if (consoleOpen) {
                document.getElementById('console-input').focus();
            }
        }

        function executeCommand(input) {
            const output = document.getElementById('console-output');
            const parts = input.trim().split(/\s+/);
            const cmd = parts[0].toLowerCase();
            const args = parts.slice(1);

            // Add to history
            consoleHistory.push(input);
            historyIndex = consoleHistory.length;

            // Show input
            output.innerHTML += `<div class="cmd-input">&gt; ${input}</div>`;

            if (cheatCommands[cmd]) {
                const result = cheatCommands[cmd](args);
                if (result) {
                    output.innerHTML += `<div class="cmd-success">${result.replace(/\n/g, '<br>')}</div>`;
                }
            } else if (cmd) {
                output.innerHTML += `<div class="cmd-error">Unknown command: ${cmd}. Type 'help' for available commands.</div>`;
            }

            // Scroll to bottom
            output.scrollTop = output.scrollHeight;
        }

        function toggleSound() {
            soundSystem.enabled = !soundSystem.enabled;
            document.getElementById('sound-toggle').textContent = soundSystem.enabled ? 'üîä' : 'üîá';
            if (soundSystem.enabled) {
                soundSystem.playClick();
            }
        }

        function toggleTechTree() {
            const panel = document.getElementById('tech-tree-panel');
            panel.classList.toggle('active');
            if (panel.classList.contains('active')) {
                renderTechTree();
            }
        }

        function renderTechTree() {
            const content = document.getElementById('tech-tree-content');
            content.innerHTML = '';

            const ages = ['Stone Age', 'Bronze Age', 'Iron Age', 'Imperial Age'];

            for (let age = 0; age < 4; age++) {
                const column = document.createElement('div');
                column.className = 'tech-age-column';

                const title = document.createElement('div');
                title.className = 'tech-age-title';
                title.textContent = ages[age];
                column.appendChild(title);

                // Find techs for this age
                for (const [techId, tech] of Object.entries(TECH_TREE)) {
                    if (tech.age === age) {
                        const item = document.createElement('div');
                        item.className = 'tech-item';

                        // Check if locked or researched
                        const isResearched = gameState.researchedTechs && gameState.researchedTechs.includes(techId);
                        const canResearch = age <= gameState.currentAge &&
                            tech.requires.every(req => gameState.researchedTechs && gameState.researchedTechs.includes(req));

                        if (isResearched) {
                            item.classList.add('researched');
                        } else if (!canResearch) {
                            item.classList.add('locked');
                        }

                        item.innerHTML = `
                            <div class="tech-item-name">${tech.name}</div>
                            <div class="tech-item-desc">${tech.description}</div>
                            <div class="tech-item-cost">${Object.entries(tech.cost).map(([r, v]) => `${v} ${r}`).join(', ')}</div>
                        `;

                        if (!isResearched && canResearch) {
                            item.onclick = () => researchTech(techId);
                        }

                        column.appendChild(item);
                    }
                }

                content.appendChild(column);
            }
        }

        function researchTech(techId) {
            const tech = TECH_TREE[techId];
            if (!canAfford(tech.cost)) {
                showMessage('Not enough resources!', 'error');
                return;
            }

            spendResources(tech.cost);

            if (!gameState.researchedTechs) {
                gameState.researchedTechs = [];
            }
            gameState.researchedTechs.push(techId);

            // Apply effects
            if (tech.effect.attackBonus) {
                gameState.techBonuses = gameState.techBonuses || {};
                gameState.techBonuses.attack = (gameState.techBonuses.attack || 0) + tech.effect.attackBonus;
            }
            if (tech.effect.defenseBonus) {
                gameState.techBonuses = gameState.techBonuses || {};
                gameState.techBonuses.defense = (gameState.techBonuses.defense || 0) + tech.effect.defenseBonus;
            }

            showMessage(`Researched: ${tech.name}!`, 'success');
            soundSystem.playTrain();
            renderTechTree();
        }

        // ============================================
        // UPGRADE UTILITY FUNCTIONS
        // ============================================
        function getUnitStats(unit) {
            const baseDef = UNITS[unit.type];
            const isPlayer = unit.owner === 'player';

            // Only player units get upgrades and tech bonuses
            const attackBonus = isPlayer ? gameState.upgrades.attackLevel * UPGRADES.attack.bonusPerLevel + (gameState.techBonuses.attack || 0) : 0;
            const defenseBonus = isPlayer ? gameState.upgrades.defenseLevel * UPGRADES.defense.bonusPerLevel + (gameState.techBonuses.defense || 0) : 0;
            const hpBonus = isPlayer ? gameState.upgrades.hpLevel * UPGRADES.hp.bonusPerLevel + (gameState.techBonuses.hp || 0) : 0;
            const speedBonus = isPlayer ? gameState.upgrades.speedLevel * UPGRADES.speed.bonusPerLevel + (gameState.techBonuses.speed || 0) : 0;

            return {
                attack: baseDef.attack + attackBonus,
                defense: baseDef.defense + defenseBonus,
                maxHp: baseDef.hp + hpBonus,
                speed: baseDef.speed + speedBonus,
                range: baseDef.range
            };
        }

        function applyUpgrade(upgradeType) {
            const upgrade = UPGRADES[upgradeType];
            const levelKey = upgradeType + 'Level';
            const currentLevel = gameState.upgrades[levelKey];

            if (currentLevel >= upgrade.maxLevel) {
                showMessage('Maximum level reached!', 'error');
                return false;
            }

            const cost = upgrade.costs[currentLevel];
            if (!canAfford(cost)) {
                showMessage('Not enough resources!', 'error');
                return false;
            }

            spendResources(cost);
            gameState.upgrades[levelKey]++;

            // Apply HP bonus to existing units
            if (upgradeType === 'hp') {
                for (const unit of gameState.units) {
                    const hpIncrease = UPGRADES.hp.bonusPerLevel;
                    unit.maxHp += hpIncrease;
                    unit.hp += hpIncrease; // Also heal by the bonus amount
                }
            }

            showMessage(`${upgrade.name} Level ${gameState.upgrades[levelKey]}!`, 'success');
            updateUpgradeUI();
            return true;
        }

        function advanceAge() {
            if (gameState.currentAge >= 3) {
                showMessage('Already at maximum age!', 'error');
                return false;
            }

            const cost = AGE_COSTS[gameState.currentAge];
            if (!canAfford(cost)) {
                showMessage('Not enough resources for age advancement!', 'error');
                return false;
            }

            spendResources(cost);
            gameState.currentAge++;
            showMessage(`Advanced to ${gameState.ages[gameState.currentAge]}!`, 'success');
            updateUpgradeUI();
            return true;
        }

        // ============================================
        // DEATH AND REMOVAL FUNCTIONS
        // ============================================
        function removeBuilding(building) {
            const def = BUILDINGS[building.type];

            // Clear map tiles
            for (let dy = 0; dy < def.height; dy++) {
                for (let dx = 0; dx < def.width; dx++) {
                    const mapX = building.x + dx;
                    const mapY = building.y + dy;
                    if (mapX >= 0 && mapX < CONFIG.MAP_WIDTH && mapY >= 0 && mapY < CONFIG.MAP_HEIGHT) {
                        gameState.map[mapY][mapX].building = null;
                    }
                }
            }

            // Remove from appropriate array
            if (building.owner === 'player') {
                const idx = gameState.buildings.indexOf(building);
                if (idx >= 0) {
                    gameState.buildings.splice(idx, 1);
                    if (def.populationProvided) {
                        gameState.maxPopulation -= def.populationProvided;
                    }
                }
            } else if (typeof building.owner === 'number') {
                // AI player building
                const ai = aiPlayers.find(a => a.id === building.owner);
                if (ai) {
                    const idx = ai.buildings.indexOf(building);
                    if (idx >= 0) {
                        ai.buildings.splice(idx, 1);
                    }
                }
            } else {
                // Legacy enemy buildings
                const idx = gameState.enemyBuildings.indexOf(building);
                if (idx >= 0) {
                    gameState.enemyBuildings.splice(idx, 1);
                }
            }
        }

        function removeUnit(unit) {
            if (unit.owner === 'player') {
                const idx = gameState.units.indexOf(unit);
                if (idx >= 0) {
                    gameState.population -= UNITS[unit.type].population;
                    gameState.units.splice(idx, 1);
                }
            } else if (typeof unit.owner === 'number') {
                // AI player unit
                const ai = aiPlayers.find(a => a.id === unit.owner);
                if (ai) {
                    const idx = ai.units.indexOf(unit);
                    if (idx >= 0) {
                        ai.units.splice(idx, 1);
                    }
                }
            } else {
                // Legacy enemy units
                const idx = gameState.enemyUnits.indexOf(unit);
                if (idx >= 0) {
                    gameState.enemyUnits.splice(idx, 1);
                }
            }

            // Clear any units targeting this one (including AI units)
            const allUnits = [...gameState.units, ...gameState.enemyUnits, ...aiPlayers.flatMap(ai => ai.units)];
            for (const u of allUnits) {
                if (u.attacking === unit) {
                    u.attacking = null;
                }
            }
        }

        // ============================================
        // CANVAS SETUP
        // ============================================
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        const minimapCanvas = document.getElementById('minimap');
        const minimapCtx = minimapCanvas.getContext('2d');

        function resizeCanvas() {
            const container = document.getElementById('main-area');
            canvas.width = container.clientWidth - 280;
            canvas.height = container.clientHeight;
            minimapCanvas.width = 180;
            minimapCanvas.height = 60;
        }

        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // ============================================
        // MAP GENERATION
        // ============================================
        const TERRAIN = {
            GRASS: { color: '#4a7c23', walkable: true },
            FOREST: { color: '#2d5016', walkable: false, icon: 'üå≤' },
            WATER: { color: '#1e5799', walkable: false },
            MOUNTAIN: { color: '#6b6b6b', walkable: false, icon: '‚õ∞Ô∏è' },
            GOLD_DEPOSIT: { color: '#8b7355', walkable: true, icon: 'ü™ô', resource: 'gold' },
            STONE_DEPOSIT: { color: '#808080', walkable: true, icon: 'ü™®', resource: 'stone' },
            GEM_DEPOSIT: { color: '#9370db', walkable: true, icon: 'üíé', resource: 'gems' }
        };

        function generateMap() {
            gameState.map = [];
            const mapType = GAME_SETTINGS.mapType;
            const resourceDensity = GAME_SETTINGS.mapResources === 'scarce' ? 0.5 :
                                    GAME_SETTINGS.mapResources === 'abundant' ? 2.0 : 1.0;

            for (let y = 0; y < CONFIG.MAP_HEIGHT; y++) {
                gameState.map[y] = [];
                for (let x = 0; x < CONFIG.MAP_WIDTH; x++) {
                    let terrain = 'GRASS';
                    const rand = Math.random();
                    const nx = x / CONFIG.MAP_WIDTH;
                    const ny = y / CONFIG.MAP_HEIGHT;

                    // Generate terrain based on map type
                    switch (mapType) {
                        case 'continental':
                            // Water on edges, land in center
                            const edgeDist = Math.min(nx, 1 - nx, ny, 1 - ny);
                            if (edgeDist < 0.08 && rand < 0.7) terrain = 'WATER';
                            else if (rand < 0.08) terrain = 'FOREST';
                            else if (edgeDist < 0.15 && rand < 0.15) terrain = 'MOUNTAIN';
                            break;

                        case 'islands':
                            // Multiple island clusters
                            const islandNoise = Math.sin(x * 0.15) * Math.cos(y * 0.12) +
                                               Math.sin(x * 0.08 + y * 0.1) * 0.5;
                            if (islandNoise < -0.3) terrain = 'WATER';
                            else if (rand < 0.06) terrain = 'FOREST';
                            break;

                        case 'desert':
                            // Mostly sand/grass with rare oases
                            if (rand < 0.03) terrain = 'WATER'; // Oases
                            else if (rand < 0.06) terrain = 'FOREST'; // Palm trees
                            else if (rand < 0.15) terrain = 'STONE_DEPOSIT'; // Rocky desert
                            break;

                        case 'forest':
                            // Dense forest coverage
                            if (rand < 0.35) terrain = 'FOREST';
                            else if (rand < 0.40) terrain = 'MOUNTAIN';
                            const streamNoise = Math.sin(x * 0.2 + y * 0.1);
                            if (streamNoise > 0.9) terrain = 'WATER';
                            break;

                        case 'highlands':
                            // Mountainous with valleys
                            const heightNoise = Math.sin(x * 0.1) * Math.cos(y * 0.1) +
                                               Math.sin(x * 0.05) * Math.cos(y * 0.08);
                            if (heightNoise > 0.5) terrain = 'MOUNTAIN';
                            else if (heightNoise < -0.5 && rand < 0.3) terrain = 'WATER';
                            else if (rand < 0.1) terrain = 'FOREST';
                            break;

                        case 'archipelago':
                            // Many small islands
                            const archNoise = Math.sin(x * 0.25) * Math.cos(y * 0.2) +
                                             Math.sin(x * 0.15 + y * 0.18) * 0.7 +
                                             Math.sin(x * 0.3) * 0.3;
                            if (archNoise < 0.2) terrain = 'WATER';
                            else if (rand < 0.05) terrain = 'FOREST';
                            break;

                        default:
                            const waterNoise = Math.sin(x * 0.1) * Math.cos(y * 0.15) + Math.sin(x * 0.05 + y * 0.08);
                            if (waterNoise > 1.2) terrain = 'WATER';
                            else if (rand < 0.08) terrain = 'FOREST';
                    }

                    // Add resource deposits (scaled by resource density)
                    if (terrain === 'GRASS') {
                        if (rand < 0.01 * resourceDensity) terrain = 'GOLD_DEPOSIT';
                        else if (rand < 0.02 * resourceDensity) terrain = 'STONE_DEPOSIT';
                        else if (rand < 0.025 * resourceDensity) terrain = 'GEM_DEPOSIT';
                    }

                    // Mountain borders for all map types
                    if ((x < 2 || x > CONFIG.MAP_WIDTH - 3 || y < 2 || y > CONFIG.MAP_HEIGHT - 3) && rand < 0.3) {
                        terrain = 'MOUNTAIN';
                    }

                    gameState.map[y][x] = {
                        terrain: terrain,
                        building: null,
                        unit: null
                    };
                }
            }

            // Clear player starting area (top-left)
            clearAreaForBase(5, 5, 14, 12);

            // Place initial player town center
            placeBuilding('townCenter', 7, 7, 'player');

            // Add some starting villagers
            for (let i = 0; i < 3; i++) {
                createUnit('villager', 6 + i, 11, 'player');
            }

            // Setup AI player bases
            setupAIBases();
        }

        function clearAreaForBase(startX, startY, endX, endY) {
            for (let y = startY; y < endY && y < CONFIG.MAP_HEIGHT; y++) {
                for (let x = startX; x < endX && x < CONFIG.MAP_WIDTH; x++) {
                    if (y >= 0 && x >= 0) {
                        gameState.map[y][x].terrain = 'GRASS';
                    }
                }
            }
        }

        function setupAIBases() {
            // Initialize AI players with bases at their positions
            initializeAIPlayers();

            for (const ai of aiPlayers) {
                // Clear area for this AI's base
                clearAreaForBase(ai.baseX - 3, ai.baseY - 3, ai.baseX + 10, ai.baseY + 8);

                // Place AI town center and barracks
                const tc = {
                    type: 'townCenter',
                    x: ai.baseX,
                    y: ai.baseY,
                    owner: ai.id,
                    hp: BUILDINGS.townCenter.hp,
                    maxHp: BUILDINGS.townCenter.hp,
                    isComplete: true,
                    trainingQueue: []
                };
                ai.buildings.push(tc);

                // Mark tiles for town center
                for (let dy = 0; dy < 3; dy++) {
                    for (let dx = 0; dx < 3; dx++) {
                        if (gameState.map[ai.baseY + dy] && gameState.map[ai.baseY + dy][ai.baseX + dx]) {
                            gameState.map[ai.baseY + dy][ai.baseX + dx].building = tc;
                        }
                    }
                }

                // Place barracks
                const barracks = {
                    type: 'barracks',
                    x: ai.baseX + 4,
                    y: ai.baseY + 1,
                    owner: ai.id,
                    hp: BUILDINGS.barracks.hp,
                    maxHp: BUILDINGS.barracks.hp,
                    isComplete: true,
                    trainingQueue: []
                };
                ai.buildings.push(barracks);

                for (let dy = 0; dy < 2; dy++) {
                    for (let dx = 0; dx < 3; dx++) {
                        if (gameState.map[ai.baseY + 1 + dy] && gameState.map[ai.baseY + 1 + dy][ai.baseX + 4 + dx]) {
                            gameState.map[ai.baseY + 1 + dy][ai.baseX + 4 + dx].building = barracks;
                        }
                    }
                }

                // Create starting units based on difficulty
                const unitCount = ai.difficulty === 'easy' ? 3 : ai.difficulty === 'hard' ? 7 : 5;
                for (let i = 0; i < unitCount; i++) {
                    const unit = {
                        id: Date.now() + Math.random() + i,
                        type: i < 2 ? 'swordsman' : (Math.random() < 0.5 ? 'swordsman' : 'archer'),
                        x: ai.baseX + (i % 3),
                        y: ai.baseY + 4 + Math.floor(i / 3),
                        owner: ai.id,
                        hp: UNITS.swordsman.hp,
                        maxHp: UNITS.swordsman.hp,
                        targetX: null,
                        targetY: null,
                        attacking: null,
                        stance: 'aggressive'
                    };
                    ai.units.push(unit);
                }
            }
        }

        // ============================================
        // BUILDING PLACEMENT
        // ============================================
        function canPlaceBuilding(type, x, y) {
            const building = BUILDINGS[type];
            
            for (let dy = 0; dy < building.height; dy++) {
                for (let dx = 0; dx < building.width; dx++) {
                    const mapX = x + dx;
                    const mapY = y + dy;
                    
                    if (mapX < 0 || mapX >= CONFIG.MAP_WIDTH || mapY < 0 || mapY >= CONFIG.MAP_HEIGHT) {
                        return false;
                    }
                    
                    const tile = gameState.map[mapY][mapX];
                    if (!TERRAIN[tile.terrain].walkable || tile.building) {
                        return false;
                    }
                }
            }
            return true;
        }

        function canAfford(costs) {
            for (const [resource, amount] of Object.entries(costs)) {
                if ((gameState.resources[resource] || 0) < amount) {
                    return false;
                }
            }
            return true;
        }

        function spendResources(costs) {
            for (const [resource, amount] of Object.entries(costs)) {
                gameState.resources[resource] -= amount;
            }
            updateResourceDisplay();
        }

        function placeBuilding(type, x, y, owner = 'player') {
            const buildingDef = BUILDINGS[type];
            
            const building = {
                id: Date.now() + Math.random(),
                type: type,
                x: x,
                y: y,
                owner: owner,
                hp: buildingDef.hp,
                maxHp: buildingDef.hp,
                constructionProgress: owner === 'player' ? 0 : 100,
                isComplete: owner !== 'player' ? true : false,
                trainingQueue: [],
                trainingProgress: 0
            };

            // Mark tiles as occupied
            for (let dy = 0; dy < buildingDef.height; dy++) {
                for (let dx = 0; dx < buildingDef.width; dx++) {
                    gameState.map[y + dy][x + dx].building = building;
                }
            }

            if (owner === 'player') {
                gameState.buildings.push(building);
                if (buildingDef.populationProvided) {
                    gameState.maxPopulation += buildingDef.populationProvided;
                }
            } else {
                gameState.enemyBuildings.push(building);
            }

            return building;
        }

        // ============================================
        // UNIT MANAGEMENT
        // ============================================
        function createUnit(type, x, y, owner = 'player') {
            const unitDef = UNITS[type];

            // Calculate HP with upgrades for player units
            let maxHp = unitDef.hp;
            if (owner === 'player') {
                maxHp += gameState.upgrades.hpLevel * UPGRADES.hp.bonusPerLevel;
            }

            const unit = {
                id: Date.now() + Math.random(),
                type: type,
                x: x,
                y: y,
                owner: owner,
                hp: maxHp,
                maxHp: maxHp,
                targetX: null,
                targetY: null,
                attacking: null,
                moveProgress: 0,
                lastAttackTime: 0,
                stance: 'aggressive', // aggressive, defensive, patrol, hold
                patrolPoints: [], // For patrol mode
                patrolIndex: 0
            };

            if (owner === 'player') {
                gameState.units.push(unit);
                gameState.population += unitDef.population;
            } else {
                gameState.enemyUnits.push(unit);
            }

            return unit;
        }

        // ============================================
        // RENDERING
        // ============================================
        function render() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const startX = Math.floor(gameState.camera.x / CONFIG.TILE_SIZE);
            const startY = Math.floor(gameState.camera.y / CONFIG.TILE_SIZE);
            const endX = Math.min(startX + Math.ceil(canvas.width / CONFIG.TILE_SIZE) + 1, CONFIG.MAP_WIDTH);
            const endY = Math.min(startY + Math.ceil(canvas.height / CONFIG.TILE_SIZE) + 1, CONFIG.MAP_HEIGHT);

            // Draw terrain
            for (let y = Math.max(0, startY); y < endY; y++) {
                for (let x = Math.max(0, startX); x < endX; x++) {
                    const tile = gameState.map[y][x];
                    const terrainInfo = TERRAIN[tile.terrain];
                    const screenX = x * CONFIG.TILE_SIZE - gameState.camera.x;
                    const screenY = y * CONFIG.TILE_SIZE - gameState.camera.y;

                    ctx.fillStyle = terrainInfo.color;
                    ctx.fillRect(screenX, screenY, CONFIG.TILE_SIZE, CONFIG.TILE_SIZE);

                    // Grid lines
                    ctx.strokeStyle = 'rgba(0,0,0,0.1)';
                    ctx.strokeRect(screenX, screenY, CONFIG.TILE_SIZE, CONFIG.TILE_SIZE);

                    // Terrain icons
                    if (terrainInfo.icon) {
                        ctx.font = `${CONFIG.TILE_SIZE * 0.6}px serif`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(terrainInfo.icon, screenX + CONFIG.TILE_SIZE / 2, screenY + CONFIG.TILE_SIZE / 2);
                    }
                }
            }

            // Draw buildings (including all AI player buildings)
            const aiBuildings = aiPlayers.flatMap(ai => ai.buildings);
            const allBuildings = [...gameState.buildings, ...gameState.enemyBuildings, ...aiBuildings];
            for (const building of allBuildings) {
                const def = BUILDINGS[building.type];
                const screenX = building.x * CONFIG.TILE_SIZE - gameState.camera.x;
                const screenY = building.y * CONFIG.TILE_SIZE - gameState.camera.y;
                const width = def.width * CONFIG.TILE_SIZE;
                const height = def.height * CONFIG.TILE_SIZE;

                // Get color based on owner
                let fillColor, borderColor;
                if (building.owner === 'player') {
                    fillColor = 'rgba(100, 149, 237, 0.7)';
                    borderColor = '#4169E1';
                } else if (typeof building.owner === 'number' && aiPlayers[building.owner]) {
                    // AI player - use their color
                    const aiColor = aiPlayers[building.owner].color;
                    fillColor = aiColor + 'B3'; // Add alpha
                    borderColor = aiColor;
                } else {
                    fillColor = 'rgba(220, 60, 60, 0.7)';
                    borderColor = '#8B0000';
                }

                // Building base
                ctx.fillStyle = fillColor;
                ctx.fillRect(screenX, screenY, width, height);

                // Border
                ctx.strokeStyle = borderColor;
                ctx.lineWidth = 2;
                ctx.strokeRect(screenX, screenY, width, height);

                // Icon
                ctx.font = `${Math.min(width, height) * 0.5}px serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillStyle = '#fff';
                ctx.fillText(def.icon, screenX + width / 2, screenY + height / 2);

                // Health bar - always show for visibility
                const hpWidth = width * 0.8;
                const hpHeight = 8;
                const hpX = screenX + (width - hpWidth) / 2;
                const hpY = screenY - 18;

                // Background
                ctx.fillStyle = '#222';
                ctx.fillRect(hpX - 1, hpY - 1, hpWidth + 2, hpHeight + 2);

                // HP bar
                const hpPercent = Math.max(0, building.hp / building.maxHp);
                let hpColor;
                if (hpPercent > 0.6) hpColor = '#4CAF50';
                else if (hpPercent > 0.3) hpColor = '#FFC107';
                else hpColor = '#f44336';

                ctx.fillStyle = '#444';
                ctx.fillRect(hpX, hpY, hpWidth, hpHeight);
                ctx.fillStyle = hpColor;
                ctx.fillRect(hpX, hpY, hpWidth * hpPercent, hpHeight);

                // Numeric HP display
                ctx.font = 'bold 10px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillStyle = '#fff';
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 2;
                const hpText = `${Math.ceil(building.hp)}/${building.maxHp}`;
                ctx.strokeText(hpText, screenX + width / 2, hpY + hpHeight / 2);
                ctx.fillText(hpText, screenX + width / 2, hpY + hpHeight / 2);

                // Construction progress
                if (!building.isComplete) {
                    ctx.fillStyle = 'rgba(0,0,0,0.5)';
                    ctx.fillRect(screenX, screenY, width, height * (1 - building.constructionProgress / 100));
                    
                    ctx.fillStyle = '#fff';
                    ctx.font = '12px Arial';
                    ctx.fillText(`${Math.floor(building.constructionProgress)}%`, screenX + width / 2, screenY + height / 2 + 20);
                }

                // Selection indicator
                if (gameState.selectedBuilding === building) {
                    ctx.strokeStyle = '#FFD700';
                    ctx.lineWidth = 3;
                    ctx.setLineDash([5, 5]);
                    ctx.strokeRect(screenX - 2, screenY - 2, width + 4, height + 4);
                    ctx.setLineDash([]);
                }
            }

            // Draw units (including all AI player units)
            const aiUnits = aiPlayers.flatMap(ai => ai.units);
            const allUnits = [...gameState.units, ...gameState.enemyUnits, ...aiUnits];
            for (const unit of allUnits) {
                const def = UNITS[unit.type];
                const screenX = unit.x * CONFIG.TILE_SIZE - gameState.camera.x;
                const screenY = unit.y * CONFIG.TILE_SIZE - gameState.camera.y;

                // Get color based on owner
                let fillColor, strokeColor;
                if (unit.owner === 'player') {
                    fillColor = 'rgba(100, 149, 237, 0.9)';
                    strokeColor = '#1a3a7a';
                } else if (typeof unit.owner === 'number' && aiPlayers[unit.owner]) {
                    // AI player - use their color
                    fillColor = aiPlayers[unit.owner].color + 'E6'; // Add alpha
                    strokeColor = aiPlayers[unit.owner].color;
                } else {
                    fillColor = 'rgba(220, 60, 60, 0.9)';
                    strokeColor = '#5a1010';
                }

                // Unit circle
                ctx.beginPath();
                ctx.arc(screenX + CONFIG.TILE_SIZE / 2, screenY + CONFIG.TILE_SIZE / 2, CONFIG.TILE_SIZE * 0.4, 0, Math.PI * 2);
                ctx.fillStyle = fillColor;
                ctx.fill();
                ctx.strokeStyle = strokeColor;
                ctx.lineWidth = 2;
                ctx.stroke();

                // Icon
                ctx.font = `${CONFIG.TILE_SIZE * 0.5}px serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillStyle = '#fff';
                ctx.fillText(def.icon, screenX + CONFIG.TILE_SIZE / 2, screenY + CONFIG.TILE_SIZE / 2);

                // Health bar - always show for visibility
                const unitHpWidth = CONFIG.TILE_SIZE * 0.9;
                const unitHpHeight = 6;
                const unitHpX = screenX + (CONFIG.TILE_SIZE - unitHpWidth) / 2;
                const unitHpY = screenY - 12;

                // Background
                ctx.fillStyle = '#222';
                ctx.fillRect(unitHpX - 1, unitHpY - 1, unitHpWidth + 2, unitHpHeight + 2);

                // HP bar
                const unitHpPercent = Math.max(0, unit.hp / unit.maxHp);
                let unitHpColor;
                if (unitHpPercent > 0.6) unitHpColor = '#4CAF50';
                else if (unitHpPercent > 0.3) unitHpColor = '#FFC107';
                else unitHpColor = '#f44336';

                ctx.fillStyle = '#444';
                ctx.fillRect(unitHpX, unitHpY, unitHpWidth, unitHpHeight);
                ctx.fillStyle = unitHpColor;
                ctx.fillRect(unitHpX, unitHpY, unitHpWidth * unitHpPercent, unitHpHeight);

                // Numeric HP display
                ctx.font = 'bold 9px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillStyle = '#fff';
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 2;
                const unitHpText = `${Math.ceil(unit.hp)}`;
                ctx.strokeText(unitHpText, screenX + CONFIG.TILE_SIZE / 2, unitHpY + unitHpHeight / 2);
                ctx.fillText(unitHpText, screenX + CONFIG.TILE_SIZE / 2, unitHpY + unitHpHeight / 2);

                // Show attack indicator when in combat
                if (unit.attacking) {
                    ctx.font = '12px serif';
                    ctx.fillStyle = '#ff4444';
                    ctx.fillText('‚öîÔ∏è', screenX + CONFIG.TILE_SIZE - 5, screenY + 5);
                }

                // Selection indicator
                if (gameState.selectedUnits.includes(unit)) {
                    ctx.beginPath();
                    ctx.arc(screenX + CONFIG.TILE_SIZE / 2, screenY + CONFIG.TILE_SIZE / 2, CONFIG.TILE_SIZE * 0.5, 0, Math.PI * 2);
                    ctx.strokeStyle = '#FFD700';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([3, 3]);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }

                // Movement indicator
                if (unit.targetX !== null && unit.owner === 'player' && gameState.selectedUnits.includes(unit)) {
                    ctx.beginPath();
                    ctx.setLineDash([4, 4]);
                    ctx.strokeStyle = 'rgba(144, 238, 144, 0.6)';
                    ctx.moveTo(screenX + CONFIG.TILE_SIZE / 2, screenY + CONFIG.TILE_SIZE / 2);
                    ctx.lineTo(
                        unit.targetX * CONFIG.TILE_SIZE - gameState.camera.x + CONFIG.TILE_SIZE / 2,
                        unit.targetY * CONFIG.TILE_SIZE - gameState.camera.y + CONFIG.TILE_SIZE / 2
                    );
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
            }

            // Draw placement preview
            if (gameState.placingBuilding) {
                const mousePos = getMouseTilePos();
                if (mousePos) {
                    const def = BUILDINGS[gameState.placingBuilding];
                    const canPlace = canPlaceBuilding(gameState.placingBuilding, mousePos.x, mousePos.y);
                    
                    ctx.globalAlpha = 0.6;
                    ctx.fillStyle = canPlace ? 'rgba(100, 200, 100, 0.5)' : 'rgba(200, 100, 100, 0.5)';
                    ctx.fillRect(
                        mousePos.x * CONFIG.TILE_SIZE - gameState.camera.x,
                        mousePos.y * CONFIG.TILE_SIZE - gameState.camera.y,
                        def.width * CONFIG.TILE_SIZE,
                        def.height * CONFIG.TILE_SIZE
                    );
                    
                    ctx.font = `${Math.min(def.width, def.height) * CONFIG.TILE_SIZE * 0.5}px serif`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillStyle = '#fff';
                    ctx.fillText(
                        def.icon,
                        mousePos.x * CONFIG.TILE_SIZE - gameState.camera.x + (def.width * CONFIG.TILE_SIZE) / 2,
                        mousePos.y * CONFIG.TILE_SIZE - gameState.camera.y + (def.height * CONFIG.TILE_SIZE) / 2
                    );
                    ctx.globalAlpha = 1;
                }
            }

            // Draw fog of war
            if (fogState.enabled) {
                for (let y = Math.max(0, startY); y < endY; y++) {
                    for (let x = Math.max(0, startX); x < endX; x++) {
                        const screenX = x * CONFIG.TILE_SIZE - gameState.camera.x;
                        const screenY = y * CONFIG.TILE_SIZE - gameState.camera.y;

                        if (!fogState.explored[y][x]) {
                            // Completely unexplored - solid black
                            ctx.fillStyle = 'rgba(0, 0, 0, 0.95)';
                            ctx.fillRect(screenX, screenY, CONFIG.TILE_SIZE, CONFIG.TILE_SIZE);
                        } else if (!fogState.visible[y][x]) {
                            // Explored but not visible - semi-transparent
                            ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
                            ctx.fillRect(screenX, screenY, CONFIG.TILE_SIZE, CONFIG.TILE_SIZE);
                        }
                    }
                }
            }

            // Render selection box if dragging
            if (isDragging && !gameState.placingBuilding) {
                const rect = canvas.getBoundingClientRect();
                const currentMouseX = mouseX;
                const currentMouseY = mouseY;
                const dragDistX = Math.abs(currentMouseX - dragStartX);
                const dragDistY = Math.abs(currentMouseY - dragStartY);

                if (dragDistX > 10 || dragDistY > 10) {
                    const boxX = Math.min(dragStartX, currentMouseX) - rect.left;
                    const boxY = Math.min(dragStartY, currentMouseY) - rect.top;
                    const boxWidth = Math.abs(currentMouseX - dragStartX);
                    const boxHeight = Math.abs(currentMouseY - dragStartY);

                    ctx.strokeStyle = '#00ff00';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 3]);
                    ctx.strokeRect(boxX, boxY, boxWidth, boxHeight);
                    ctx.setLineDash([]);
                    ctx.fillStyle = 'rgba(0, 255, 0, 0.1)';
                    ctx.fillRect(boxX, boxY, boxWidth, boxHeight);
                }
            }

            // Render minimap
            renderMinimap();
        }

        function renderMinimap() {
            const scaleX = minimapCanvas.width / CONFIG.MAP_WIDTH;
            const scaleY = minimapCanvas.height / CONFIG.MAP_HEIGHT;

            minimapCtx.fillStyle = '#2d5016';
            minimapCtx.fillRect(0, 0, minimapCanvas.width, minimapCanvas.height);

            // Terrain
            for (let y = 0; y < CONFIG.MAP_HEIGHT; y++) {
                for (let x = 0; x < CONFIG.MAP_WIDTH; x++) {
                    const tile = gameState.map[y][x];
                    if (tile.terrain !== 'GRASS') {
                        minimapCtx.fillStyle = TERRAIN[tile.terrain].color;
                        minimapCtx.fillRect(x * scaleX, y * scaleY, Math.max(1, scaleX), Math.max(1, scaleY));
                    }
                }
            }

            // Buildings (including AI)
            const minimapBuildings = [...gameState.buildings, ...gameState.enemyBuildings, ...aiPlayers.flatMap(ai => ai.buildings)];
            for (const building of minimapBuildings) {
                const def = BUILDINGS[building.type];
                if (building.owner === 'player') {
                    minimapCtx.fillStyle = '#4169E1';
                } else if (typeof building.owner === 'number' && aiPlayers[building.owner]) {
                    minimapCtx.fillStyle = aiPlayers[building.owner].color;
                } else {
                    minimapCtx.fillStyle = '#DC143C';
                }
                minimapCtx.fillRect(
                    building.x * scaleX,
                    building.y * scaleY,
                    def.width * scaleX,
                    def.height * scaleY
                );
            }

            // Units (including AI)
            const minimapUnits = [...gameState.units, ...gameState.enemyUnits, ...aiPlayers.flatMap(ai => ai.units)];
            for (const unit of minimapUnits) {
                if (unit.owner === 'player') {
                    minimapCtx.fillStyle = '#87CEEB';
                } else if (typeof unit.owner === 'number' && aiPlayers[unit.owner]) {
                    minimapCtx.fillStyle = aiPlayers[unit.owner].color;
                } else {
                    minimapCtx.fillStyle = '#FF6B6B';
                }
                minimapCtx.fillRect(unit.x * scaleX, unit.y * scaleY, 2, 2);
            }

            // Viewport
            minimapCtx.strokeStyle = '#FFD700';
            minimapCtx.lineWidth = 1;
            minimapCtx.strokeRect(
                gameState.camera.x / CONFIG.TILE_SIZE * scaleX,
                gameState.camera.y / CONFIG.TILE_SIZE * scaleY,
                (canvas.width / CONFIG.TILE_SIZE) * scaleX,
                (canvas.height / CONFIG.TILE_SIZE) * scaleY
            );
        }

        // ============================================
        // INPUT HANDLING
        // ============================================
        let mouseX = 0, mouseY = 0;
        let isDragging = false;
        let dragStartX = 0, dragStartY = 0;

        function getMouseTilePos() {
            const rect = canvas.getBoundingClientRect();
            const x = Math.floor((mouseX - rect.left + gameState.camera.x) / CONFIG.TILE_SIZE);
            const y = Math.floor((mouseY - rect.top + gameState.camera.y) / CONFIG.TILE_SIZE);
            if (x >= 0 && x < CONFIG.MAP_WIDTH && y >= 0 && y < CONFIG.MAP_HEIGHT) {
                return { x, y };
            }
            return null;
        }

        canvas.addEventListener('mousemove', (e) => {
            mouseX = e.clientX;
            mouseY = e.clientY;
        });

        canvas.addEventListener('mousedown', (e) => {
            if (e.button === 0) {
                isDragging = true;
                dragStartX = e.clientX;
                dragStartY = e.clientY;
            }
        });

        canvas.addEventListener('mouseup', (e) => {
            const pos = getMouseTilePos();
            
            if (e.button === 0) { // Left click
                if (gameState.placingBuilding && pos) {
                    // Try to place building
                    if (canPlaceBuilding(gameState.placingBuilding, pos.x, pos.y)) {
                        const def = BUILDINGS[gameState.placingBuilding];
                        if (canAfford(def.cost)) {
                            spendResources(def.cost);
                            placeBuilding(gameState.placingBuilding, pos.x, pos.y, 'player');
                            showMessage(`${def.name} placed!`, 'success');
                            gameState.placingBuilding = null;
                            updateBuildButtons();
                        } else {
                            showMessage('Not enough resources!', 'error');
                        }
                    } else {
                        showMessage('Cannot build here!', 'error');
                    }
                } else if (pos) {
                    // Check if this was a box selection drag
                    const rect = canvas.getBoundingClientRect();
                    const dragEndX = e.clientX;
                    const dragEndY = e.clientY;
                    const dragDistX = Math.abs(dragEndX - dragStartX);
                    const dragDistY = Math.abs(dragEndY - dragStartY);

                    if (dragDistX > 10 || dragDistY > 10) {
                        // Box selection - calculate world coordinates
                        const startWorldX = (Math.min(dragStartX, dragEndX) - rect.left + gameState.camera.x) / CONFIG.TILE_SIZE;
                        const startWorldY = (Math.min(dragStartY, dragEndY) - rect.top + gameState.camera.y) / CONFIG.TILE_SIZE;
                        const endWorldX = (Math.max(dragStartX, dragEndX) - rect.left + gameState.camera.x) / CONFIG.TILE_SIZE;
                        const endWorldY = (Math.max(dragStartY, dragEndY) - rect.top + gameState.camera.y) / CONFIG.TILE_SIZE;

                        // Find all player units within the box
                        const selectedUnits = gameState.units.filter(u => {
                            const unitX = u.x;
                            const unitY = u.y;
                            return unitX >= startWorldX && unitX <= endWorldX &&
                                   unitY >= startWorldY && unitY <= endWorldY;
                        });

                        if (selectedUnits.length > 0) {
                            gameState.selectedUnits = selectedUnits;
                            gameState.selectedBuilding = null;
                            showMessage(`Selected ${selectedUnits.length} unit(s)`, 'success');
                            updateSelectionUI();
                        }
                    } else {
                        // Single click selection
                        const tile = gameState.map[pos.y][pos.x];

                        // Check for unit - use floor to handle floating point positions
                        const clickedUnit = [...gameState.units].find(u =>
                            Math.floor(u.x) === pos.x && Math.floor(u.y) === pos.y
                        );
                        if (clickedUnit) {
                            gameState.selectedUnits = [clickedUnit];
                            gameState.selectedBuilding = null;
                            updateSelectionUI();
                        }
                        // Check for building
                        else if (tile.building && tile.building.owner === 'player') {
                            gameState.selectedBuilding = tile.building;
                            gameState.selectedUnits = [];
                            updateSelectionUI();
                        } else {
                            gameState.selectedBuilding = null;
                            gameState.selectedUnits = [];
                            updateSelectionUI();
                        }
                    }
                }
                isDragging = false;
            }
            
            if (e.button === 2 && pos) { // Right click
                if (gameState.placingBuilding) {
                    gameState.placingBuilding = null;
                    updateBuildButtons();
                } else if (gameState.selectedUnits.length > 0) {
                    // Check if targeting an enemy (use Math.floor for float positions)
                    // Include AI player units and buildings
                    let enemyUnit = gameState.enemyUnits.find(u =>
                        Math.floor(u.x) === pos.x && Math.floor(u.y) === pos.y
                    );
                    // Also check AI player units
                    if (!enemyUnit) {
                        for (const ai of aiPlayers) {
                            enemyUnit = ai.units.find(u =>
                                Math.floor(u.x) === pos.x && Math.floor(u.y) === pos.y
                            );
                            if (enemyUnit) break;
                        }
                    }

                    let enemyBuilding = gameState.enemyBuildings.find(b => {
                        const def = BUILDINGS[b.type];
                        return pos.x >= b.x && pos.x < b.x + def.width &&
                               pos.y >= b.y && pos.y < b.y + def.height;
                    });
                    // Also check AI player buildings
                    if (!enemyBuilding) {
                        for (const ai of aiPlayers) {
                            enemyBuilding = ai.buildings.find(b => {
                                const def = BUILDINGS[b.type];
                                return pos.x >= b.x && pos.x < b.x + def.width &&
                                       pos.y >= b.y && pos.y < b.y + def.height;
                            });
                            if (enemyBuilding) break;
                        }
                    }

                    for (const unit of gameState.selectedUnits) {
                        const stance = unit.stance || 'aggressive';

                        // Handle patrol mode - add patrol point
                        if (stance === 'patrol') {
                            if (!unit.patrolPoints) unit.patrolPoints = [];
                            // Add current position if first point
                            if (unit.patrolPoints.length === 0) {
                                unit.patrolPoints.push({ x: Math.floor(unit.x), y: Math.floor(unit.y) });
                            }
                            // Add the clicked position
                            unit.patrolPoints.push({ x: pos.x, y: pos.y });
                            // Limit to 8 patrol points
                            if (unit.patrolPoints.length > 8) {
                                unit.patrolPoints = unit.patrolPoints.slice(-8);
                            }
                        } else {
                            // Normal move command
                            unit.targetX = pos.x;
                            unit.targetY = pos.y;
                        }

                        if (enemyUnit) {
                            unit.attacking = enemyUnit;
                        } else if (enemyBuilding) {
                            unit.attacking = enemyBuilding;
                        } else if (stance !== 'patrol') {
                            unit.attacking = null;
                        }
                    }

                    const stance = gameState.selectedUnits[0]?.stance || 'aggressive';
                    if (stance === 'patrol') {
                        showMessage(`Patrol point added (${gameState.selectedUnits[0].patrolPoints.length} points)`, 'success');
                    } else {
                        showMessage('Units moving', 'success');
                    }
                }
            }
        });

        canvas.addEventListener('contextmenu', (e) => e.preventDefault());

        document.addEventListener('keydown', (e) => {
            // Console toggle
            if (e.key === '`' || e.key === '~') {
                e.preventDefault();
                toggleConsole();
                return;
            }

            // If console is open, handle console input
            if (consoleOpen) {
                if (e.key === 'Enter') {
                    const input = document.getElementById('console-input');
                    if (input.value.trim()) {
                        executeCommand(input.value);
                        input.value = '';
                    }
                } else if (e.key === 'ArrowUp') {
                    e.preventDefault();
                    if (historyIndex > 0) {
                        historyIndex--;
                        document.getElementById('console-input').value = consoleHistory[historyIndex];
                    }
                } else if (e.key === 'ArrowDown') {
                    e.preventDefault();
                    if (historyIndex < consoleHistory.length - 1) {
                        historyIndex++;
                        document.getElementById('console-input').value = consoleHistory[historyIndex];
                    } else {
                        historyIndex = consoleHistory.length;
                        document.getElementById('console-input').value = '';
                    }
                } else if (e.key === 'Escape') {
                    toggleConsole();
                }
                return;
            }

            const speed = CONFIG.CAMERA_SPEED;
            switch (e.key) {
                case 'ArrowUp':
                case 'w':
                    gameState.camera.y = Math.max(0, gameState.camera.y - speed);
                    break;
                case 'ArrowDown':
                case 's':
                    gameState.camera.y = Math.min(CONFIG.MAP_HEIGHT * CONFIG.TILE_SIZE - canvas.height, gameState.camera.y + speed);
                    break;
                case 'ArrowLeft':
                case 'a':
                    gameState.camera.x = Math.max(0, gameState.camera.x - speed);
                    break;
                case 'ArrowRight':
                case 'd':
                    gameState.camera.x = Math.min(CONFIG.MAP_WIDTH * CONFIG.TILE_SIZE - canvas.width, gameState.camera.x + speed);
                    break;
                case 'Escape':
                    if (gameState.placingBuilding) {
                        gameState.placingBuilding = null;
                        updateBuildButtons();
                    } else if (gameState.selectedBuilding || gameState.selectedUnits.length > 0) {
                        gameState.selectedBuilding = null;
                        gameState.selectedUnits = [];
                        updateSelectionUI();
                    } else if (GAME_SETTINGS.gameStarted) {
                        // Toggle pause menu
                        if (GAME_SETTINGS.gamePaused) {
                            resumeGame();
                        } else {
                            pauseGame();
                        }
                    }
                    break;
                case 't':
                    // Toggle tech tree
                    toggleTechTree();
                    break;
                case 'g':
                    // Toggle diplomacy panel
                    toggleDiplomacy();
                    break;
            }
        });

        // Build button handlers
        document.querySelectorAll('.build-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const buildingType = btn.dataset.building;
                if (buildingType && !btn.classList.contains('disabled')) {
                    gameState.placingBuilding = buildingType;
                    updateBuildButtons();
                }
            });
        });

        // ============================================
        // UI UPDATES
        // ============================================
        function updateResourceDisplay() {
            document.getElementById('food-amount').textContent = Math.floor(gameState.resources.food);
            document.getElementById('wood-amount').textContent = Math.floor(gameState.resources.wood);
            document.getElementById('stone-amount').textContent = Math.floor(gameState.resources.stone);
            document.getElementById('gold-amount').textContent = Math.floor(gameState.resources.gold);
            document.getElementById('gems-amount').textContent = Math.floor(gameState.resources.gems);
            document.getElementById('pop-amount').textContent = `${gameState.population}/${gameState.maxPopulation}`;

            document.getElementById('food-rate').textContent = `+${gameState.resourceRates.food}/s`;
            document.getElementById('wood-rate').textContent = `+${gameState.resourceRates.wood}/s`;
            document.getElementById('stone-rate').textContent = `+${gameState.resourceRates.stone}/s`;
            document.getElementById('gold-rate').textContent = `+${gameState.resourceRates.gold}/s`;
            document.getElementById('gems-rate').textContent = `+${gameState.resourceRates.gems}/s`;
        }

        function updateBuildButtons() {
            document.querySelectorAll('.build-btn').forEach(btn => {
                const buildingType = btn.dataset.building;
                if (buildingType) {
                    const def = BUILDINGS[buildingType];
                    const affordable = canAfford(def.cost);
                    btn.classList.toggle('disabled', !affordable);
                    btn.classList.toggle('selected', gameState.placingBuilding === buildingType);
                }
            });
        }

        function updateUpgradeUI() {
            // Update age display
            document.getElementById('current-age').textContent = gameState.ages[gameState.currentAge];

            const ageBtn = document.getElementById('advance-age-btn');
            if (gameState.currentAge >= 3) {
                ageBtn.textContent = 'Max Age';
                ageBtn.classList.add('disabled');
            } else {
                const cost = AGE_COSTS[gameState.currentAge];
                const costStr = Object.entries(cost).map(([r, v]) => {
                    const icons = { food: 'üåæ', wood: 'ü™µ', stone: 'ü™®', gold: 'ü™ô', gems: 'üíé' };
                    return `${v}${icons[r]}`;
                }).join(' ');
                ageBtn.innerHTML = `Advance to ${gameState.ages[gameState.currentAge + 1]}<br><small>${costStr}</small>`;
                ageBtn.classList.toggle('disabled', !canAfford(cost));
            }

            // Update upgrade buttons
            const upgradeTypes = ['attack', 'defense', 'hp', 'speed'];
            for (const type of upgradeTypes) {
                const upgrade = UPGRADES[type];
                const levelKey = type + 'Level';
                const currentLevel = gameState.upgrades[levelKey];
                const btn = document.querySelector(`.upgrade-btn[data-upgrade="${type}"]`);

                if (btn) {
                    const levelEl = document.getElementById(`${type}-level`);
                    const costEl = document.getElementById(`${type}-cost`);

                    levelEl.textContent = `Lv.${currentLevel}`;

                    if (currentLevel >= upgrade.maxLevel) {
                        costEl.textContent = 'MAX';
                        btn.classList.add('maxed');
                        btn.classList.remove('disabled');
                    } else {
                        const cost = upgrade.costs[currentLevel];
                        const costStr = Object.entries(cost).map(([r, v]) => {
                            const icons = { food: 'üåæ', wood: 'ü™µ', stone: 'ü™®', gold: 'ü™ô', gems: 'üíé' };
                            return `${v}${icons[r]}`;
                        }).join(' ');
                        costEl.textContent = costStr;
                        btn.classList.remove('maxed');
                        btn.classList.toggle('disabled', !canAfford(cost));
                    }
                }
            }
        }

        function updateSelectionUI() {
            const portrait = document.getElementById('sel-portrait');
            const name = document.getElementById('sel-name');
            const stats = document.getElementById('sel-stats');
            const actions = document.getElementById('unit-actions');

            if (gameState.selectedBuilding) {
                const building = gameState.selectedBuilding;
                const def = BUILDINGS[building.type];
                portrait.textContent = def.icon;
                name.textContent = def.name;
                stats.textContent = `HP: ${building.hp}/${building.maxHp}`;
                
                // Show production buttons
                actions.innerHTML = '';
                if (def.produces && building.isComplete) {
                    for (const unitType of def.produces) {
                        const unitDef = UNITS[unitType];
                        const btn = document.createElement('button');
                        btn.className = 'action-btn';
                        btn.textContent = unitDef.icon;
                        btn.title = `Train ${unitDef.name}`;
                        btn.onclick = () => trainUnit(building, unitType);
                        actions.appendChild(btn);
                    }
                }
            } else if (gameState.selectedUnits.length > 0) {
                const unit = gameState.selectedUnits[0];
                const def = UNITS[unit.type];
                const unitStats = getUnitStats(unit);

                portrait.textContent = def.icon;
                name.textContent = gameState.selectedUnits.length > 1
                    ? `${gameState.selectedUnits.length} units selected`
                    : def.name;

                // Show stats with upgrade bonuses highlighted
                const attackBonus = unitStats.attack - def.attack;
                const defenseBonus = unitStats.defense - def.defense;
                const hpBonus = unit.maxHp - def.hp;

                let statsHtml = `HP: ${Math.ceil(unit.hp)}/${unit.maxHp}`;
                if (hpBonus > 0) statsHtml += `<span style="color:#90EE90">(+${hpBonus})</span>`;
                statsHtml += ` | ATK: ${unitStats.attack}`;
                if (attackBonus > 0) statsHtml += `<span style="color:#90EE90">(+${attackBonus})</span>`;
                statsHtml += ` | DEF: ${unitStats.defense}`;
                if (defenseBonus > 0) statsHtml += `<span style="color:#90EE90">(+${defenseBonus})</span>`;
                statsHtml += ` | SPD: ${unitStats.speed.toFixed(1)}`;

                stats.innerHTML = statsHtml;

                // Show unit command buttons
                actions.innerHTML = '';

                const stances = [
                    { id: 'aggressive', icon: '‚öîÔ∏è', label: 'Attack (auto-attack enemies)' },
                    { id: 'defensive', icon: 'üõ°Ô∏è', label: 'Defend (attack only in range)' },
                    { id: 'patrol', icon: 'üîÑ', label: 'Patrol (move between points)' },
                    { id: 'hold', icon: 'üö´', label: 'Hold Position (no movement)' }
                ];

                for (const stance of stances) {
                    const btn = document.createElement('button');
                    btn.className = 'action-btn' + (unit.stance === stance.id ? ' active' : '');
                    btn.textContent = stance.icon;
                    btn.title = stance.label;
                    btn.onclick = () => setUnitStance(stance.id);
                    actions.appendChild(btn);
                }

                // Stop button
                const stopBtn = document.createElement('button');
                stopBtn.className = 'action-btn';
                stopBtn.textContent = '‚èπÔ∏è';
                stopBtn.title = 'Stop all actions';
                stopBtn.onclick = () => stopUnits();
                actions.appendChild(stopBtn);

            } else {
                portrait.textContent = '-';
                name.textContent = 'No Selection';
                stats.textContent = 'Click on a building or unit';
                actions.innerHTML = '';
            }
        }

        function setUnitStance(stance) {
            for (const unit of gameState.selectedUnits) {
                unit.stance = stance;
                if (stance === 'patrol' && unit.patrolPoints.length === 0) {
                    // Set current position as first patrol point
                    unit.patrolPoints = [{ x: Math.floor(unit.x), y: Math.floor(unit.y) }];
                }
                if (stance === 'hold') {
                    unit.targetX = null;
                    unit.targetY = null;
                    unit.attacking = null;
                }
            }
            showMessage(`Stance set to ${stance}`, 'success');
            updateSelectionUI();
        }

        function stopUnits() {
            for (const unit of gameState.selectedUnits) {
                unit.targetX = null;
                unit.targetY = null;
                unit.attacking = null;
                unit.patrolPoints = [];
            }
            showMessage('Units stopped', 'success');
        }

        function showMessage(text, type = 'info') {
            const container = document.getElementById('messages');
            const msg = document.createElement('div');
            msg.className = `message ${type}`;
            msg.textContent = text;
            container.appendChild(msg);
            
            setTimeout(() => {
                msg.remove();
            }, 3000);
        }

        // ============================================
        // GAME LOGIC
        // ============================================
        function trainUnit(building, unitType) {
            const unitDef = UNITS[unitType];
            
            if (!canAfford(unitDef.cost)) {
                showMessage('Not enough resources!', 'error');
                return;
            }
            
            if (gameState.population + unitDef.population > gameState.maxPopulation) {
                showMessage('Need more houses!', 'error');
                return;
            }
            
            spendResources(unitDef.cost);
            building.trainingQueue.push({
                type: unitType,
                progress: 0,
                trainTime: unitDef.trainTime
            });
            showMessage(`Training ${unitDef.name}...`, 'success');
        }

        function updateGame(deltaTime) {
            gameState.gameTime += deltaTime;

            // Resource generation
            gameState.resourceRates = { food: 0, wood: 0, stone: 0, gold: 0, gems: 0 };
            
            for (const building of gameState.buildings) {
                // Construction progress
                if (!building.isComplete) {
                    building.constructionProgress += deltaTime / 50;
                    if (building.constructionProgress >= 100) {
                        building.isComplete = true;
                        building.constructionProgress = 100;
                        showMessage(`${BUILDINGS[building.type].name} complete!`, 'success');
                    }
                }
                
                // Resource generation
                if (building.isComplete) {
                    const def = BUILDINGS[building.type];
                    if (def.resourceGen) {
                        for (const [resource, rate] of Object.entries(def.resourceGen)) {
                            gameState.resourceRates[resource] += rate;
                        }
                    }
                    
                    // Unit training
                    if (building.trainingQueue.length > 0) {
                        const training = building.trainingQueue[0];
                        training.progress += deltaTime;
                        
                        if (training.progress >= training.trainTime) {
                            building.trainingQueue.shift();
                            const def = BUILDINGS[building.type];
                            
                            // Find spawn location
                            let spawnX = building.x + def.width;
                            let spawnY = building.y + def.height;
                            
                            for (let dy = 0; dy <= def.height; dy++) {
                                for (let dx = -1; dx <= def.width; dx++) {
                                    const tx = building.x + dx;
                                    const ty = building.y + def.height;
                                    if (tx >= 0 && ty >= 0 && tx < CONFIG.MAP_WIDTH && ty < CONFIG.MAP_HEIGHT) {
                                        const tile = gameState.map[ty][tx];
                                        if (TERRAIN[tile.terrain].walkable && !tile.building) {
                                            spawnX = tx;
                                            spawnY = ty;
                                            break;
                                        }
                                    }
                                }
                            }
                            
                            createUnit(training.type, spawnX, spawnY, 'player');
                            showMessage(`${UNITS[training.type].name} trained!`, 'success');
                        }
                    }
                }
            }

            // Apply resource rates
            for (const [resource, rate] of Object.entries(gameState.resourceRates)) {
                gameState.resources[resource] += rate * deltaTime / 1000;
            }

            // Collect units to remove (to avoid modifying array while iterating)
            const unitsToRemove = [];
            const buildingsToRemove = [];

            // Unit movement and combat - include AI player units
            const allUnits = [...gameState.units, ...gameState.enemyUnits, ...aiPlayers.flatMap(ai => ai.units)];
            for (const unit of allUnits) {
                // Skip if unit is dead
                if (unit.hp <= 0) continue;

                const stats = getUnitStats(unit);
                const baseDef = UNITS[unit.type];

                if (unit.attacking) {
                    // Check if target still exists and is alive
                    const targetExists = unit.attacking && unit.attacking.hp > 0;
                    if (!targetExists) {
                        unit.attacking = null;
                        continue;
                    }

                    // Move towards target or attack if in range
                    let targetX, targetY;
                    if (BUILDINGS[unit.attacking.type]) {
                        // It's a building - target center
                        const bDef = BUILDINGS[unit.attacking.type];
                        targetX = unit.attacking.x + Math.floor(bDef.width / 2);
                        targetY = unit.attacking.y + Math.floor(bDef.height / 2);
                    } else {
                        targetX = unit.attacking.x;
                        targetY = unit.attacking.y;
                    }

                    const dist = Math.sqrt(Math.pow(unit.x - targetX, 2) + Math.pow(unit.y - targetY, 2));

                    if (dist <= stats.range + 0.5) {
                        // Attack with proper damage calculation
                        const attackDamage = stats.attack;
                        let targetDefense = 0;

                        // Get target's defense
                        if (unit.attacking.type && UNITS[unit.attacking.type]) {
                            const targetStats = getUnitStats(unit.attacking);
                            targetDefense = targetStats.defense;
                        }

                        // Calculate actual damage (minimum 1)
                        const actualDamage = Math.max(1, attackDamage - targetDefense * 0.5);
                        unit.attacking.hp -= actualDamage * deltaTime / 1000;

                        // Check for death
                        if (unit.attacking.hp <= 0) {
                            unit.attacking.hp = 0;
                            const targetName = UNITS[unit.attacking.type]?.name || BUILDINGS[unit.attacking.type]?.name || 'Target';

                            if (BUILDINGS[unit.attacking.type]) {
                                buildingsToRemove.push(unit.attacking);
                                showMessage(`${targetName} destroyed!`, unit.owner === 'player' ? 'success' : 'error');
                            } else {
                                unitsToRemove.push(unit.attacking);
                                showMessage(`${targetName} killed!`, unit.owner === 'player' ? 'success' : 'error');
                            }
                            unit.attacking = null;
                        }
                    } else {
                        // Move towards target
                        unit.targetX = targetX;
                        unit.targetY = targetY;
                    }
                }

                // Auto-aggro: Units attack nearby enemies based on stance and diplomacy
                const stance = unit.stance || 'aggressive';

                if (stance !== 'hold') {
                    if (!unit.attacking) {
                        // Get all potential enemy units based on diplomacy
                        let enemyUnits = [];

                        if (unit.owner === 'player') {
                            // Player units can attack AI units we're at war with
                            for (const ai of aiPlayers) {
                                if (diplomacy.isAtWar(ai.id)) {
                                    enemyUnits.push(...ai.units);
                                }
                            }
                            // Also include legacy enemyUnits
                            enemyUnits.push(...gameState.enemyUnits);
                        } else if (typeof unit.owner === 'number') {
                            // AI unit - attack player units if at war
                            if (diplomacy.isAtWar(unit.owner)) {
                                enemyUnits.push(...gameState.units);
                            }
                            // AI units can attack other AI units they're at war with (future feature)
                        } else {
                            // Legacy enemy units
                            enemyUnits.push(...gameState.units);
                        }

                        // Aggressive: attack enemies in detection range
                        // Defensive: attack only enemies in attack range
                        const detectionRange = stance === 'defensive' ? stats.range : stats.range + 4;

                        for (const enemy of enemyUnits) {
                            if (enemy.hp <= 0) continue;
                            const dist = Math.sqrt(Math.pow(unit.x - enemy.x, 2) + Math.pow(unit.y - enemy.y, 2));
                            if (dist <= detectionRange) {
                                unit.attacking = enemy;
                                break;
                            }
                        }
                    }

                    // Patrol behavior
                    if (stance === 'patrol' && !unit.attacking && unit.patrolPoints && unit.patrolPoints.length >= 2) {
                        const currentTarget = unit.patrolPoints[unit.patrolIndex || 0];
                        const distToPoint = Math.sqrt(
                            Math.pow(unit.x - currentTarget.x, 2) +
                            Math.pow(unit.y - currentTarget.y, 2)
                        );

                        if (distToPoint < 0.5) {
                            // Reached patrol point, move to next
                            unit.patrolIndex = ((unit.patrolIndex || 0) + 1) % unit.patrolPoints.length;
                        }

                        const nextTarget = unit.patrolPoints[unit.patrolIndex || 0];
                        unit.targetX = nextTarget.x;
                        unit.targetY = nextTarget.y;
                    }
                }

                // Movement (skip if hold stance)
                if (stance !== 'hold' && unit.targetX !== null && unit.targetY !== null) {
                    const dx = unit.targetX - unit.x;
                    const dy = unit.targetY - unit.y;

                    if (Math.abs(dx) < 0.1 && Math.abs(dy) < 0.1) {
                        unit.x = unit.targetX;
                        unit.y = unit.targetY;
                        unit.targetX = null;
                        unit.targetY = null;
                    } else {
                        const speed = stats.speed * deltaTime / 1000;
                        if (Math.abs(dx) > Math.abs(dy)) {
                            unit.x += Math.sign(dx) * Math.min(Math.abs(dx), speed);
                        } else {
                            unit.y += Math.sign(dy) * Math.min(Math.abs(dy), speed);
                        }
                    }
                }
            }

            // Remove dead units and buildings
            for (const unit of unitsToRemove) {
                removeUnit(unit);
            }
            for (const building of buildingsToRemove) {
                removeBuilding(building);
            }

            // Tower attacks - include AI player buildings
            const allBuildings = [...gameState.buildings, ...gameState.enemyBuildings, ...aiPlayers.flatMap(ai => ai.buildings)];
            for (const building of allBuildings) {
                if (building.type === 'tower' && building.isComplete && building.hp > 0) {
                    const def = BUILDINGS.tower;
                    let enemyUnits = [];

                    if (building.owner === 'player') {
                        // Player tower attacks AI units we're at war with
                        for (const ai of aiPlayers) {
                            if (diplomacy.isAtWar(ai.id)) {
                                enemyUnits.push(...ai.units);
                            }
                        }
                        enemyUnits.push(...gameState.enemyUnits);
                    } else if (typeof building.owner === 'number') {
                        // AI tower attacks player units if at war
                        if (diplomacy.isAtWar(building.owner)) {
                            enemyUnits.push(...gameState.units);
                        }
                    } else {
                        // Legacy enemy tower
                        enemyUnits.push(...gameState.units);
                    }

                    for (const enemy of enemyUnits) {
                        if (enemy.hp <= 0) continue;
                        const dist = Math.sqrt(Math.pow(building.x - enemy.x, 2) + Math.pow(building.y - enemy.y, 2));
                        if (dist <= def.range) {
                            enemy.hp -= def.attack * deltaTime / 1000;
                            if (enemy.hp <= 0) {
                                enemy.hp = 0;
                                removeUnit(enemy);
                                showMessage(`Tower killed ${UNITS[enemy.type].name}!`, building.owner === 'player' ? 'success' : 'error');
                            }
                            break; // Tower attacks one at a time
                        }
                    }
                }
            }

            // Update all AI players
            if (gameState.aiEnabled) {
                updateAllAIPlayers(deltaTime);
            }

            // Update diplomacy timers
            diplomacy.update(deltaTime);

            // Update fog of war
            updateFogOfWar();

            // Check win/lose conditions
            const totalEnemyBuildings = gameState.enemyBuildings.length +
                aiPlayers.reduce((sum, ai) => sum + ai.buildings.length, 0);

            if (totalEnemyBuildings === 0 && GAME_SETTINGS.gameStarted) {
                document.getElementById('overlay-title').textContent = 'üèÜ Victory! üèÜ';
                document.getElementById('game-overlay').style.display = 'flex';
                GAME_SETTINGS.gameStarted = false; // Prevent repeated triggers
            } else if (gameState.buildings.length === 0 && GAME_SETTINGS.gameStarted) {
                document.getElementById('overlay-title').textContent = 'üíÄ Defeat üíÄ';
                document.getElementById('game-overlay').style.display = 'flex';
                GAME_SETTINGS.gameStarted = false; // Prevent repeated triggers
            }

            updateResourceDisplay();
            updateBuildButtons();
            updateUpgradeUI();
        }

        // ============================================
        // GAME LOOP
        // ============================================
        let lastTime = 0;

        function gameLoop(timestamp) {
            const deltaTime = timestamp - lastTime;
            lastTime = timestamp;

            // Only update game logic if not paused
            if (!GAME_SETTINGS.gamePaused && deltaTime < 100) {
                updateGame(deltaTime * (gameState.gameSpeed || 1));
                updateEdgeScrolling();
            }

            render();
            requestAnimationFrame(gameLoop);
        }

        // ============================================
        // INITIALIZATION
        // ============================================
        function init() {
            // Just check for saved games and show main menu
            updateContinueButton();
            soundSystem.init();
        }

        function startNewGame() {
            // Read settings from UI
            GAME_SETTINGS.mapSize = document.getElementById('map-size').value;
            GAME_SETTINGS.mapType = document.getElementById('map-type').value;
            GAME_SETTINGS.mapResources = document.getElementById('map-resources').value;
            GAME_SETTINGS.playerName = document.getElementById('player-name').value || 'Your Kingdom';
            GAME_SETTINGS.startingAge = parseInt(document.getElementById('starting-age').value);
            GAME_SETTINGS.startingResources = document.getElementById('starting-resources').value;

            // Update CONFIG based on map size
            const mapSize = MAP_SIZES[GAME_SETTINGS.mapSize];
            CONFIG.MAP_WIDTH = mapSize.width;
            CONFIG.MAP_HEIGHT = mapSize.height;

            // Set starting resources
            const startRes = STARTING_RESOURCES[GAME_SETTINGS.startingResources];
            gameState.resources = { ...startRes };
            gameState.currentAge = GAME_SETTINGS.startingAge;

            // Reset game state
            gameState.buildings = [];
            gameState.units = [];
            gameState.enemyBuildings = [];
            gameState.enemyUnits = [];
            gameState.population = 0;
            gameState.maxPopulation = 10;
            gameState.selectedBuilding = null;
            gameState.selectedUnits = [];
            gameState.placingBuilding = null;
            gameState.gameTime = 0;
            gameState.upgrades = { attackLevel: 0, defenseLevel: 0, hpLevel: 0, speedLevel: 0 };
            gameState.researchedTechs = [];
            gameState.techBonuses = { attack: 0, defense: 0, speed: 0, hp: 0 };
            aiPlayers = [];

            // Hide menus, show game
            document.getElementById('main-menu').classList.add('hidden');
            document.getElementById('game-setup').classList.remove('active');
            document.getElementById('game-container').classList.remove('hidden');

            // Initialize and start game
            initializeGame();
        }

        function initializeGame() {
            GAME_SETTINGS.gameStarted = true;
            GAME_SETTINGS.gamePaused = false;

            // Hide any overlays
            document.getElementById('game-overlay').style.display = 'none';

            generateMap();

            // Initialize diplomacy after AI players are created
            diplomacy.initialize();

            // Initialize fog of war arrays
            fogState.explored = [];
            fogState.visible = [];
            for (let y = 0; y < CONFIG.MAP_HEIGHT; y++) {
                fogState.explored[y] = [];
                fogState.visible[y] = [];
                for (let x = 0; x < CONFIG.MAP_WIDTH; x++) {
                    fogState.explored[y][x] = false;
                    fogState.visible[y][x] = false;
                }
            }

            // Resize canvas (accounting for build panel)
            resizeCanvas();

            updateResourceDisplay();
            updateBuildButtons();
            updateSelectionUI();
            updateUpgradeUI();
            updateFogOfWar();
            updateAgeDisplay();

            showMessage(`Welcome, ${GAME_SETTINGS.playerName}!`, 'success');
            showMessage(`Fighting ${GAME_SETTINGS.opponents.length} opponent(s)`, 'info');
            showMessage('Press ESC for menu | ` for console', 'info');

            requestAnimationFrame(gameLoop);
        }

        function initializeGameFromSave(data) {
            GAME_SETTINGS.gameStarted = true;
            GAME_SETTINGS.gamePaused = false;

            // Hide any overlays
            document.getElementById('game-overlay').style.display = 'none';

            // Restore game state
            gameState.resources = { ...data.gameState.resources };
            gameState.population = data.gameState.population;
            gameState.maxPopulation = data.gameState.maxPopulation;
            gameState.currentAge = data.gameState.currentAge;
            gameState.gameTime = data.gameState.gameTime;
            gameState.upgrades = { ...data.gameState.upgrades };
            gameState.researchedTechs = [...data.gameState.researchedTechs];
            gameState.techBonuses = { ...data.gameState.techBonuses };

            // Generate map structure
            gameState.map = [];
            for (let y = 0; y < CONFIG.MAP_HEIGHT; y++) {
                gameState.map[y] = [];
                for (let x = 0; x < CONFIG.MAP_WIDTH; x++) {
                    gameState.map[y][x] = { terrain: 'GRASS', building: null, unit: null };
                }
            }

            // Restore buildings
            gameState.buildings = [];
            gameState.enemyBuildings = [];
            for (const b of data.buildings) {
                const building = {
                    id: Date.now() + Math.random(),
                    ...b,
                    trainingQueue: [],
                    trainingProgress: 0,
                    constructionProgress: 100
                };
                if (b.owner === 'player') {
                    gameState.buildings.push(building);
                }
                // Mark tiles
                const def = BUILDINGS[b.type];
                for (let dy = 0; dy < def.height; dy++) {
                    for (let dx = 0; dx < def.width; dx++) {
                        if (gameState.map[b.y + dy] && gameState.map[b.y + dy][b.x + dx]) {
                            gameState.map[b.y + dy][b.x + dx].building = building;
                        }
                    }
                }
            }

            // Restore units
            gameState.units = [];
            for (const u of data.units) {
                const unit = {
                    id: Date.now() + Math.random(),
                    ...u,
                    targetX: null,
                    targetY: null,
                    attacking: null,
                    moveProgress: 0,
                    lastAttackTime: 0,
                    patrolPoints: [],
                    patrolIndex: 0
                };
                gameState.units.push(unit);
            }

            // Restore AI players (simplified - recreate with saved state)
            aiPlayers = [];
            for (const aiData of data.aiPlayers) {
                const ai = createAIPlayer(aiData.id, aiData.difficulty, aiData.color, aiData.name);
                ai.resources = { ...aiData.resources };
                ai.state = aiData.state;
                ai.buildings = [];
                ai.units = [];
                aiPlayers.push(ai);
            }

            // Restore diplomacy relations or initialize fresh
            if (data.diplomacy) {
                diplomacy.relations = { ...data.diplomacy };
            } else {
                diplomacy.initialize();
            }

            // Initialize fog
            fogState.explored = [];
            fogState.visible = [];
            for (let y = 0; y < CONFIG.MAP_HEIGHT; y++) {
                fogState.explored[y] = [];
                fogState.visible[y] = [];
                for (let x = 0; x < CONFIG.MAP_WIDTH; x++) {
                    fogState.explored[y][x] = false;
                    fogState.visible[y][x] = false;
                }
            }

            // Resize canvas (accounting for build panel)
            resizeCanvas();

            updateResourceDisplay();
            updateBuildButtons();
            updateSelectionUI();
            updateUpgradeUI();
            updateFogOfWar();
            updateAgeDisplay();

            showMessage('Game loaded!', 'success');
            requestAnimationFrame(gameLoop);
        }

        function updateAgeDisplay() {
            const ageNames = ['Stone Age', 'Bronze Age', 'Iron Age', 'Imperial Age'];
            document.getElementById('current-age').textContent = ageNames[gameState.currentAge] || 'Stone Age';
        }

        // Update fog of war based on unit/building positions
        function updateFogOfWar() {
            if (!fogState.enabled) return;

            // Reset visibility (but keep explored)
            for (let y = 0; y < CONFIG.MAP_HEIGHT; y++) {
                for (let x = 0; x < CONFIG.MAP_WIDTH; x++) {
                    fogState.visible[y][x] = false;
                }
            }

            // Reveal areas around player units and buildings
            const revealers = [...gameState.units, ...gameState.buildings.map(b => ({
                x: b.x + BUILDINGS[b.type].width / 2,
                y: b.y + BUILDINGS[b.type].height / 2,
                owner: b.owner
            }))];

            for (const entity of revealers) {
                if (entity.owner === 'player') {
                    const range = fogState.visionRange;
                    for (let dy = -range; dy <= range; dy++) {
                        for (let dx = -range; dx <= range; dx++) {
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            if (dist <= range) {
                                const fx = Math.floor(entity.x + dx);
                                const fy = Math.floor(entity.y + dy);
                                if (fx >= 0 && fx < CONFIG.MAP_WIDTH && fy >= 0 && fy < CONFIG.MAP_HEIGHT) {
                                    fogState.visible[fy][fx] = true;
                                    fogState.explored[fy][fx] = true;
                                }
                            }
                        }
                    }
                }
            }
        }

        init();
    </script>
</body>
</html>
